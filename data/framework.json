{
	"meta": {
		"version": "0.3.4",
		"format": 20,
		"date": 1640896500585
	},
	"custom": {
		"general": {
			"name": "General",
			"files": {
				"welcome": {
					"name": "Welcome",
					"type": "md",
					"content": "<div align=\"center\">\n\n![Sapphire Logo](https://cdn.skyra.pw/gh-assets/sapphire-banner.png)\n\n# Sapphire\n\n**A pleasant Discord Bot framework**\n\n[![GitHub](https://img.shields.io/github/license/sapphiredev/framework)](https://github.com/sapphiredev/framework/blob/main/LICENSE.md)\n[![codecov](https://codecov.io/gh/sapphiredev/framework/branch/main/graph/badge.svg?token=AHPITY8WY9)](https://codecov.io/gh/sapphiredev/framework)\n[![npm](https://img.shields.io/npm/v/@sapphire/framework?color=crimson&logo=npm&style=flat-square)](https://www.npmjs.com/package/@sapphire/framework)\n\n[![Support Server](https://discord.com/api/guilds/737141877803057244/embed.png?style=banner2)](https://sapphirejs.dev/discord)\n\n</div>\n\n---\n\n## Description\n\nSapphire is a Discord bot framework built on top of [discord.js] for advanced and amazing bots.\n\n## Features\n\n-   Written in TypeScript\n-   Command Handler, Arguments, Pre-conditions and Listeners Store\n-   Completely Modular and Extendable\n-   Advanced Plugins Support\n-   Supports many [plugins](https://github.com/sapphiredev/plugins)\n\n## Installation\n\n`@sapphire/framework` depends on the following packages. Be sure to install these along with this package!\n\n-   [`discord.js`](https://www.npmjs.com/package/discord.js)\n\nYou can use the following command to install this package, or replace `npm install` with your package manager of choice.\n\n```sh\nnpm install @sapphire/framework discord.js\n```\n\n---\n\n## Buy us some doughnuts\n\nSapphire Community is and always will be open source, even if we don't get donations. That being said, we know there are amazing people who may still want to donate just to show their appreciation. Thank you very much in advance!\n\nWe accept donations through Open Collective, Ko-fi, Paypal, Patreon and GitHub Sponsorships. You can use the buttons below to donate through your method of choice.\n\n|   Donate With   |                       Address                       |\n| :-------------: | :-------------------------------------------------: |\n| Open Collective | [Click Here](https://sapphirejs.dev/opencollective) |\n|      Ko-fi      |      [Click Here](https://sapphirejs.dev/kofi)      |\n|     Patreon     |    [Click Here](https://sapphirejs.dev/patreon)     |\n|     PayPal      |     [Click Here](https://sapphirejs.dev/paypal)     |\n\n## Contributors ‚ú®\n\nThanks goes to these wonderful people ([emoji key](https://allcontributors.org/docs/en/emoji-key)):\n\n<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->\n<!-- prettier-ignore-start -->\n<!-- markdownlint-disable -->\n<table>\n  <tr>\n    <td align=\"center\"><a href=\"https://github.com/kyranet\"><img src=\"https://avatars0.githubusercontent.com/u/24852502?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Antonio Rom√°n</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=kyranet\" title=\"Code\">üíª</a> <a href=\"https://github.com/sapphiredev/framework/commits?author=kyranet\" title=\"Documentation\">üìñ</a> <a href=\"#design-kyranet\" title=\"Design\">üé®</a> <a href=\"#ideas-kyranet\" title=\"Ideas, Planning, & Feedback\">ü§î</a> <a href=\"#infra-kyranet\" title=\"Infrastructure (Hosting, Build-Tools, etc)\">üöá</a> <a href=\"#projectManagement-kyranet\" title=\"Project Management\">üìÜ</a> <a href=\"#plugin-kyranet\" title=\"Plugin/utility libraries\">üîå</a></td>\n    <td align=\"center\"><a href=\"https://favware.tech/\"><img src=\"https://avatars3.githubusercontent.com/u/4019718?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Jeroen Claassens</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=Favna\" title=\"Code\">üíª</a> <a href=\"https://github.com/sapphiredev/framework/commits?author=Favna\" title=\"Documentation\">üìñ</a> <a href=\"#infra-Favna\" title=\"Infrastructure (Hosting, Build-Tools, etc)\">üöá</a> <a href=\"#projectManagement-Favna\" title=\"Project Management\">üìÜ</a> <a href=\"#plugin-Favna\" title=\"Plugin/utility libraries\">üîå</a></td>\n    <td align=\"center\"><a href=\"https://github.com/cfanoulis\"><img src=\"https://avatars3.githubusercontent.com/u/38255093?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Charalampos Fanoulis</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=cfanoulis\" title=\"Code\">üíª</a></td>\n    <td align=\"center\"><a href=\"http://www.adityatd.me\"><img src=\"https://avatars0.githubusercontent.com/u/9266227?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Aditya N. Tripathi</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=AdityaTD\" title=\"Code\">üíª</a> <a href=\"https://github.com/sapphiredev/framework/commits?author=AdityaTD\" title=\"Documentation\">üìñ</a></td>\n    <td align=\"center\"><a href=\"http://leonard.sh\"><img src=\"https://avatars1.githubusercontent.com/u/35312043?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>LeonardSSH</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=LeonardSSH\" title=\"Documentation\">üìñ</a></td>\n    <td align=\"center\"><a href=\"https://Quantumlyy.com/\"><img src=\"https://avatars1.githubusercontent.com/u/7919610?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Nejc Drobniƒç</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=Quantumlyy\" title=\"Code\">üíª</a> <a href=\"#plugin-Quantumlyy\" title=\"Plugin/utility libraries\">üîå</a></td>\n    <td align=\"center\"><a href=\"https://github.com/Phamzito\"><img src=\"https://avatars2.githubusercontent.com/u/31642521?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>David Gustavo Herrera De La Cruz</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=Phamzito\" title=\"Code\">üíª</a></td>\n  </tr>\n  <tr>\n    <td align=\"center\"><a href=\"https://github.com/Rexogamer\"><img src=\"https://avatars0.githubusercontent.com/u/42586271?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Ed L</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=Rexogamer\" title=\"Documentation\">üìñ</a></td>\n    <td align=\"center\"><a href=\"https://atm.moe/\"><img src=\"https://avatars3.githubusercontent.com/u/31011461?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Kovacs Alex</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=alexthemaster\" title=\"Code\">üíª</a></td>\n    <td align=\"center\"><a href=\"https://github.com/Alcremie\"><img src=\"https://avatars0.githubusercontent.com/u/54785334?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Ivan Lieder</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=Alcremie\" title=\"Code\">üíª</a> <a href=\"https://github.com/sapphiredev/framework/pulls?q=is%3Apr+reviewed-by%3AAlcremie\" title=\"Reviewed Pull Requests\">üëÄ</a></td>\n    <td align=\"center\"><a href=\"https://github.com/Nytelife26\"><img src=\"https://avatars1.githubusercontent.com/u/22531310?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Tyler J Russell</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=Nytelife26\" title=\"Code\">üíª</a> <a href=\"#infra-Nytelife26\" title=\"Infrastructure (Hosting, Build-Tools, etc)\">üöá</a> <a href=\"#plugin-Nytelife26\" title=\"Plugin/utility libraries\">üîå</a></td>\n    <td align=\"center\"><a href=\"https://github.com/Stitch07\"><img src=\"https://avatars0.githubusercontent.com/u/29275227?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Stitch07</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=Stitch07\" title=\"Code\">üíª</a></td>\n    <td align=\"center\"><a href=\"https://lavya.tech/\"><img src=\"https://avatars.githubusercontent.com/u/65386243?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>lavgup</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=lavgup\" title=\"Documentation\">üìñ</a></td>\n    <td align=\"center\"><a href=\"https://github.com/vladfrangu\"><img src=\"https://avatars.githubusercontent.com/u/17960496?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Vlad Frangu</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=vladfrangu\" title=\"Code\">üíª</a> <a href=\"#infra-vladfrangu\" title=\"Infrastructure (Hosting, Build-Tools, etc)\">üöá</a> <a href=\"https://github.com/sapphiredev/framework/pulls?q=is%3Apr+reviewed-by%3Avladfrangu\" title=\"Reviewed Pull Requests\">üëÄ</a></td>\n  </tr>\n  <tr>\n    <td align=\"center\"><a href=\"https://github.com/noftaly\"><img src=\"https://avatars.githubusercontent.com/u/34779161?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Elliot</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=noftaly\" title=\"Documentation\">üìñ</a> <a href=\"https://github.com/sapphiredev/framework/commits?author=noftaly\" title=\"Code\">üíª</a></td>\n    <td align=\"center\"><a href=\"https://kaname.netlify.app\"><img src=\"https://avatars.githubusercontent.com/u/56084970?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Kaname</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=kaname-png\" title=\"Code\">üíª</a> <a href=\"https://github.com/sapphiredev/framework/issues?q=author%3Akaname-png\" title=\"Bug reports\">üêõ</a></td>\n    <td align=\"center\"><a href=\"https://github.com/Lioness100\"><img src=\"https://avatars.githubusercontent.com/u/65814829?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Lioness100</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=Lioness100\" title=\"Code\">üíª</a> <a href=\"https://github.com/sapphiredev/framework/commits?author=Lioness100\" title=\"Documentation\">üìñ</a> <a href=\"https://github.com/sapphiredev/framework/issues?q=author%3ALioness100\" title=\"Bug reports\">üêõ</a></td>\n    <td align=\"center\"><a href=\"https://github.com/gc\"><img src=\"https://avatars.githubusercontent.com/u/30398469?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>GC</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=gc\" title=\"Code\">üíª</a></td>\n    <td align=\"center\"><a href=\"https://minecolonies.com/\"><img src=\"https://avatars.githubusercontent.com/u/19329455?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>Mark Fisher</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=PoroUsedSnax\" title=\"Code\">üíª</a></td>\n    <td align=\"center\"><a href=\"https://github.com/bitomic\"><img src=\"https://avatars.githubusercontent.com/u/35199700?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>bitomic</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=bitomic\" title=\"Code\">üíª</a></td>\n    <td align=\"center\"><a href=\"https://c43721.github.io/\"><img src=\"https://avatars.githubusercontent.com/u/55610086?v=4?s=100\" width=\"100px;\" alt=\"\"/><br /><sub><b>c43721</b></sub></a><br /><a href=\"https://github.com/sapphiredev/framework/commits?author=c43721\" title=\"Code\">üíª</a></td>\n  </tr>\n</table>\n\n<!-- markdownlint-restore -->\n<!-- prettier-ignore-end -->\n\n<!-- ALL-CONTRIBUTORS-LIST:END -->\n\nThis project follows the [all-contributors](https://github.com/all-contributors/all-contributors) specification. Contributions of any kind welcome!\n\n[discord.js]: https://github.com/discordjs/discord.js\n",
					"path": "README.md"
				}
			}
		}
	},
	"classes": [
		{
			"name": "Args",
			"description": "The argument parser to be used in {@link Command}.",
			"construct": {
				"name": "constructor",
				"params": [
					{
						"name": "message",
						"optional": false,
						"type": [
							[
								["Message", "<"],
								["boolean", ">"]
							]
						]
					},
					{
						"name": "command",
						"optional": false,
						"type": [
							[
								["Command", "<"],
								["Args", ", "],
								["CommandOptions", ">"]
							]
						]
					},
					{
						"name": "parser",
						"optional": false,
						"type": [[["Args"]]]
					},
					{
						"name": "context",
						"optional": false,
						"type": [[["CommandContext"]]]
					}
				],
				"returns": [[["Args"]]],
				"meta": {
					"line": 57,
					"file": "Args.ts",
					"path": "src/lib/parsers"
				}
			},
			"props": [
				{
					"name": "command",
					"description": "The command that is being run.",
					"readonly": true,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					],
					"meta": {
						"line": 38,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "commandContext",
					"description": "The context of the command being run.",
					"readonly": true,
					"type": [[["CommandContext"]]],
					"meta": {
						"line": 43,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "message",
					"description": "The original message that triggered the command.",
					"readonly": true,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					],
					"meta": {
						"line": 33,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "parser",
					"description": "The internal Lexure parser.",
					"readonly": true,
					"type": [[["Args"]]],
					"meta": {
						"line": 48,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "states",
					"description": "The states stored in the args.",
					"see": ["Args#save", "Args#restore"],
					"access": "private",
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"default": "[]",
					"type": [
						[
							["Array", "<"],
							["ArgsState", ">"]
						]
					],
					"meta": {
						"line": 55,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "finished",
					"description": "Whether all arguments have been consumed.",
					"readonly": true,
					"type": [[["boolean"]]],
					"meta": {
						"line": 627,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				}
			],
			"methods": [
				{
					"name": "getFlags",
					"description": "Checks if one or more flag were given.",
					"see": [],
					"examples": [
						"```typescript\n// Suppose args are from '--f --g'.\nconsole.log(args.getFlags('f'));\n// >>> true\n\nconsole.log(args.getFlags('g', 'h'));\n// >>> true\n\nconsole.log(args.getFlags('h'));\n// >>> false\n```"
					],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "keys",
							"description": "The name(s) of the flag.",
							"optional": false,
							"type": [
								[
									["readonly", " "],
									["Array", "<"],
									["string", ">"]
								]
							]
						}
					],
					"returns": [[["boolean"]]],
					"meta": {
						"line": 564,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "getOption",
					"description": "Gets the last value of one or more options.",
					"see": [],
					"examples": [
						"```typescript\n// Suppose args are from '--a=1 --b=2 --c=3'.\nconsole.log(args.getOption('a'));\n// >>> '1'\n\nconsole.log(args.getOption('b', 'c'));\n// >>> '2'\n\nconsole.log(args.getOption('d'));\n// >>> null\n```"
					],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "keys",
							"description": "The name(s) of the option.",
							"optional": false,
							"type": [
								[
									["readonly", " "],
									["Array", "<"],
									["string", ">"]
								]
							]
						}
					],
					"returns": [[["null", " | "], ["string"]]],
					"meta": {
						"line": 584,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "getOptions",
					"description": "Gets all the values of one or more option.",
					"see": [],
					"examples": [
						"```typescript\n// Suppose args are from '--a=1 --a=1 --b=2 --c=3'.\nconsole.log(args.getOptions('a'));\n// >>> ['1', '1']\n\nconsole.log(args.getOptions('b', 'c'));\n// >>> ['2', '3']\n\nconsole.log(args.getOptions('d'));\n// >>> null\n```"
					],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "keys",
							"description": "The name(s) of the option.",
							"optional": false,
							"type": [
								[
									["readonly", " "],
									["Array", "<"],
									["string", ">"]
								]
							]
						}
					],
					"returns": [
						[
							["null", " | "],
							["Array", "<"],
							["string", ">"]
						]
					],
					"meta": {
						"line": 604,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "missingArguments",
					"returns": [
						[
							["Err", "<"],
							["UserError", ">"]
						]
					],
					"meta": {
						"line": 649,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "next",
					"description": "Similar to {@link Args.nextMaybe} but returns the value on success, null otherwise.",
					"see": [],
					"examples": ["```typescript\n// !numbers 1 2 3\n\nconsole.log(args.next());\n// -> '1'\n```"],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"returns": [[["string"]]],
					"meta": {
						"line": 525,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "nextMaybe",
					"description": "Retrieves the next raw argument from the parser.",
					"see": [],
					"examples": ["```typescript\n// !numbers 1 2 3\n\nconsole.log(args.nextMaybe());\n// -> { exists: true, value: '1' }\n```"],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"returns": [
						[
							["Maybe", "<"],
							["string", ">"]
						]
					],
					"meta": {
						"line": 492,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "peek",
					"description": "Similar to {@link Args.peekResult} but returns the value on success, throwing otherwise.",
					"see": [],
					"examples": [
						"```typescript\n// !bigintsumthensquarefirst 25 50 75\nconst resolver = Args.make((arg) => {\n  try {\n    return ok(BigInt(arg));\n  } catch {\n    return err(new UserError('InvalidBigInt', 'You must specify a valid number for a bigint.'));\n  }\n});\n\nconst peeked = await args.peek(() => args.repeatResult(resolver));\nawait message.channel.send(`Sum: **${peeked.reduce((x, y) => x + y, 0)}**`); // Sum: 150\n\nconst first = await args.pick(resolver);\nawait message.channel.send(`First bigint squared: ${first**2n}`); // First bigint squared: 625\n```"
					],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "type",
							"description": "The function, custom argument, or argument name.",
							"optional": false,
							"type": [[["(..."], ["args", ": "], ["unknown", "[]) => "], ["Result", "<"], ["T", ">"]]]
						}
					],
					"returns": [
						[
							["Promise", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 436,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "peekResult",
					"description": "Peeks the following parameter(s) without advancing the parser's state.\nPassing a function as a parameter allows for returning {@link Args.pickResult}, {@link Args.repeatResult},\nor {@link Args.restResult}; otherwise, passing the custom argument or the argument type with options\nwill use {@link Args.pickResult} and only peek a single argument.",
					"see": [],
					"examples": [
						"```typescript\n// !reversedandscreamfirst hello world\nconst resolver = Args.make((arg) => ok(arg.split('').reverse().join('')));\n\nconst result = await args.peekResult(() => args.repeatResult(resolver));\nif (isOk(result)) await message.channel.send(\n  `Reversed ${result.value.length} word(s): ${result.value.join(' ')}`\n); // Reversed 2 word(s): olleh dlrow\n\nconst firstWord = await args.pickResult('string');\nif (isOk(firstWord)) await message.channel.send(firstWord.value.toUpperCase()); // HELLO\n```"
					],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "type",
							"description": "The function, custom argument, or argument name.",
							"optional": false,
							"type": [[["(..."], ["args", ": "], ["unknown", "[]) => "], ["Result", "<"], ["T", ">"]]]
						}
					],
					"returns": [
						[
							["Promise", "<"],
							["Result", "<"],
							["T", ", "],
							["UserError", ">>"]
						]
					],
					"meta": {
						"line": 362,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "pick",
					"description": "Similar to {@link Args.pickResult} but returns the value on success, throwing otherwise.",
					"see": [],
					"examples": [
						"```typescript\n// !square 5\nconst resolver = Args.make((arg) => {\n  const parsed = Number(argument);\n  if (Number.isNaN(parsed)) return err(new UserError('ArgumentNumberNaN', 'You must write a valid number.'));\n  return ok(parsed);\n});\nconst a = await args.pick(resolver);\n\nawait message.channel.send(`The result is: ${a ** 2}!`);\n// Sends \"The result is: 25\"\n```"
					],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "type",
							"description": "The type of the argument.",
							"optional": false,
							"type": [
								[
									["IArgument", "<"],
									["T", ">"]
								]
							]
						},
						{
							"name": "options",
							"optional": true,
							"type": [[["ArgOptions"]]]
						}
					],
					"returns": [
						[
							["Promise", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 148,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "pickResult",
					"description": "Retrieves the next parameter and parses it. Advances index on success.",
					"see": [],
					"examples": [
						"```typescript\n// !square 5\nconst resolver = Args.make((arg) => {\n  const parsed = Number(argument);\n  if (Number.isNaN(parsed)) return err(new UserError('ArgumentNumberNaN', 'You must write a valid number.'));\n  return ok(parsed);\n});\nconst a = await args.pickResult(resolver);\nif (!a.success) throw new UserError('ArgumentNumberNaN', 'You must write a valid number.');\n\nawait message.channel.send(`The result is: ${a.value ** 2}!`);\n// Sends \"The result is: 25\"\n```"
					],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "type",
							"description": "The type of the argument.",
							"optional": false,
							"type": [
								[
									["IArgument", "<"],
									["T", ">"]
								]
							]
						},
						{
							"name": "options",
							"optional": true,
							"type": [[["ArgOptions"]]]
						}
					],
					"returns": [
						[
							["Promise", "<"],
							["Result", "<"],
							["T", ", "],
							["UserError", ">>"]
						]
					],
					"meta": {
						"line": 94,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "repeat",
					"description": "Similar to {@link Args.repeatResult} but returns the value on success, throwing otherwise.",
					"see": [],
					"examples": [
						"```typescript\n// !reverse-each 2 Hello World!\nconst resolver = Args.make((arg) => ok(arg.split('').reverse()));\nconst result = await args.repeat(resolver, { times: 5 });\nawait message.channel.send(`You have written ${result.length} word(s): ${result.join(' ')}`);\n// Sends \"You have written 2 word(s): Hello World!\"\n```"
					],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "type",
							"description": "The type of the argument.",
							"optional": false,
							"type": [
								[
									["IArgument", "<"],
									["T", ">"]
								]
							]
						},
						{
							"name": "options",
							"optional": true,
							"type": [[["RepeatArgOptions"]]]
						}
					],
					"returns": [
						[
							["Promise", "<"],
							["Array", "<"],
							["T", ">>"]
						]
					],
					"meta": {
						"line": 323,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "repeatResult",
					"description": "Retrieves all the following arguments.",
					"see": [],
					"examples": [
						"```typescript\n// !add 2 Hello World!\nconst resolver = Args.make((arg) => ok(arg.split('').reverse()));\nconst result = await args.repeatResult(resolver, { times: 5 });\nif (!result.success) throw new UserError('CountArgumentError', 'You must write up to 5 words.');\n\nawait message.channel.send(`You have written ${result.value.length} word(s): ${result.value.join(' ')}`);\n// Sends \"You have written 2 word(s): olleH !dlroW\"\n```"
					],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "type",
							"description": "The type of the argument.",
							"optional": false,
							"type": [
								[
									["IArgument", "<"],
									["T", ">"]
								]
							]
						},
						{
							"name": "options",
							"optional": true,
							"type": [[["RepeatArgOptions"]]]
						}
					],
					"returns": [
						[
							["Promise", "<"],
							["Result", "<"],
							["Array", "<"],
							["T", ">, "],
							["UserError", ">>"]
						]
					],
					"meta": {
						"line": 267,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "resolveArgument",
					"description": "Resolves an argument.",
					"access": "private",
					"params": [
						{
							"name": "arg",
							"description": "The argument name or {@link IArgument} instance.",
							"optional": false,
							"type": [
								[
									["keyof", " "],
									["ArgType", " | "],
									["IArgument", "<"],
									["T", ">"]
								]
							]
						}
					],
					"returns": [
						[
							["undefined", " | "],
							["IArgument", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 657,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "rest",
					"description": "Similar to {@link Args.restResult} but returns the value on success, throwing otherwise.",
					"see": [],
					"examples": [
						"```typescript\n// !reverse Hello world!\nconst resolver = Args.make((arg) => ok(arg.split('').reverse()));\nconst a = await args.rest(resolver);\nawait message.channel.send(`The reversed value is... ${a}`);\n// Sends \"The reversed value is... !dlrow olleH\"\n```"
					],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "type",
							"description": "The type of the argument.",
							"optional": false,
							"type": [
								[
									["IArgument", "<"],
									["T", ">"]
								]
							]
						},
						{
							"name": "options",
							"optional": true,
							"type": [[["ArgOptions"]]]
						}
					],
					"returns": [
						[
							["Promise", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 233,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "restResult",
					"description": "Retrieves all the following arguments.",
					"see": [],
					"examples": [
						"```typescript\n// !reverse Hello world!\nconst resolver = Args.make((arg) => ok(arg.split('').reverse()));\nconst a = await args.restResult(resolver);\nif (!a.success) throw new UserError('AddArgumentError', 'You must write some text.');\n\nawait message.channel.send(`The reversed value is... ${a.value}`);\n// Sends \"The reversed value is... !dlrow olleH\"\n```"
					],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "type",
							"description": "The type of the argument.",
							"optional": false,
							"type": [
								[
									["IArgument", "<"],
									["T", ">"]
								]
							]
						},
						{
							"name": "options",
							"optional": true,
							"type": [[["ArgOptions"]]]
						}
					],
					"returns": [
						[
							["Promise", "<"],
							["Result", "<"],
							["T", ", "],
							["UserError", ">>"]
						]
					],
					"meta": {
						"line": 182,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "restore",
					"description": "Restores the previously saved state from the stack.",
					"see": ["Args#save"],
					"examples": [],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"returns": [[["void"]]],
					"meta": {
						"line": 620,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "save",
					"description": "Saves the current state into the stack following a FILO strategy (first-in, last-out).",
					"see": ["Args#restore"],
					"examples": [],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"returns": [[["void"]]],
					"meta": {
						"line": 612,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "start",
					"description": "Sets the parser to the first token.",
					"returns": [[["Args"]]],
					"meta": {
						"line": 67,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "toJSON",
					"description": "Defines the `JSON.stringify` override.",
					"returns": [
						[
							["{"],
							["\ncommand", ": "],
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">,"],
							["\ncommandContext", ": "],
							["CommandContext", ","],
							["\nmessage", ": "],
							["Message", "<"],
							["boolean", ">"],
							["\n", "}"]
						]
					],
					"meta": {
						"line": 634,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "unavailableArgument",
					"params": [
						{
							"name": "type",
							"optional": false,
							"type": [
								[
									["string", " | "],
									["IArgument", "<"],
									["T", ">"]
								]
							]
						}
					],
					"returns": [
						[
							["Err", "<"],
							["UserError", ">"]
						]
					],
					"meta": {
						"line": 638,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "error",
					"description": "Constructs an {@link Err} result containing an {@link ArgumentError}.",
					"scope": "static",
					"params": [
						{
							"name": "options",
							"description": "The options for the argument error.",
							"optional": false,
							"type": [
								[
									["Options", "<"],
									["T", ">"]
								]
							]
						}
					],
					"returns": [
						[
							["Err", "<"],
							["ArgumentError", "<"],
							["T", ">>"]
						]
					],
					"meta": {
						"line": 682,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "make",
					"description": "Converts a callback into an usable argument.",
					"scope": "static",
					"params": [
						{
							"name": "cb",
							"description": "The callback to convert into an {@link IArgument}.",
							"optional": false,
							"type": [
								[
									["("],
									["parameter", ": "],
									["string", ", "],
									["context", ": "],
									["Context", "<"],
									["T", ">) => "],
									["Result", "<"],
									["T", ">"]
								]
							]
						},
						{
							"name": "name",
							"optional": true,
							"default": "''",
							"type": [[["string"]]]
						}
					],
					"returns": [
						[
							["IArgument", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 666,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				},
				{
					"name": "ok",
					"description": "Constructs an {@link Ok} result.",
					"scope": "static",
					"params": [
						{
							"name": "value",
							"description": "The value to pass.",
							"optional": false,
							"type": [[["T"]]]
						}
					],
					"returns": [
						[
							["Ok", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 674,
						"file": "Args.ts",
						"path": "src/lib/parsers"
					}
				}
			],
			"meta": {
				"line": 29,
				"file": "Args.ts",
				"path": "src/lib/parsers"
			}
		},
		{
			"name": "Argument",
			"description": "The base argument class. This class is abstract and is to be extended by subclasses implementing the methods. In\nSapphire's workflow, arguments are called when using {@link Args}'s methods (usually used inside {@link Command}s by default).",
			"see": [],
			"extends": ["AliasPiece<O>"],
			"implements": ["IArgument<T>"],
			"examples": [
				"```typescript\nimport { Argument, PieceContext } from '@sapphire/framework';\nimport { URL } from 'url';\n\nexport class CoreArgument extends Argument<URL> {\n  public constructor(context: PieceContext) {\n    super(context, { name: 'hyperlink', aliases: ['url'] });\n  }\n\n  public run(argument: string): Argument.Result<URL> {\n    try {\n      return this.ok(new URL(argument));\n    } catch {\n      return this.error(argument, 'ArgumentHyperlinkInvalidURL', 'The argument did not resolve to a valid URL.');\n    }\n  }\n}\n\n// Augment the ArgType structure so `args.pick('url')`, `args.repeat('url')`\n// and others have a return type of `URL`.\ndeclare module '@sapphire/framework' {\n  export interface ArgType {\n    url: URL;\n  }\n}\n```"
			],
			"abstract": false,
			"deprecated": false,
			"construct": {
				"name": "constructor",
				"params": [
					{
						"name": "context",
						"optional": false,
						"type": [[["PieceContext"]]]
					},
					{
						"name": "options",
						"optional": true,
						"type": [[["AliasPieceOptions"]]]
					}
				],
				"returns": [
					[
						["Argument", "<"],
						["T", ", "],
						["O", ">"]
					]
				]
			},
			"methods": [
				{
					"name": "error",
					"description": "Constructs an {@link ArgumentError} with a custom type.",
					"params": [
						{
							"name": "options",
							"optional": false,
							"type": [
								[
									["Omit", "<"],
									["Options", "<"],
									["T", ">, "],
									["'argument'", ">"]
								]
							]
						}
					],
					"returns": [
						[
							["Result", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 83,
						"file": "Argument.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "ok",
					"description": "Wraps a value into a successful value.",
					"params": [
						{
							"name": "value",
							"description": "The value to wrap.",
							"optional": false,
							"type": [[["T"]]]
						}
					],
					"returns": [
						[
							["Result", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 73,
						"file": "Argument.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "run",
					"description": "The method which is called when invoking the argument.",
					"params": [
						{
							"name": "parameter",
							"optional": false,
							"type": [[["string"]]]
						},
						{
							"name": "context",
							"optional": false,
							"type": [
								[
									["Context", "<"],
									["T", ">"]
								]
							]
						}
					],
					"returns": [
						[
							["Result", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 67,
						"file": "Argument.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"meta": {
				"line": 66,
				"file": "Argument.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "ArgumentError",
			"description": "Errors thrown by the argument parser",
			"see": [],
			"extends": ["UserError"],
			"examples": [],
			"abstract": false,
			"deprecated": false,
			"construct": {
				"name": "constructor",
				"description": "Constructs an UserError.",
				"params": [
					{
						"name": "options",
						"optional": false,
						"type": [
							[
								["Options", "<"],
								["T", ">"]
							]
						]
					}
				],
				"returns": [
					[
						["ArgumentError", "<"],
						["T", ">"]
					]
				],
				"meta": {
					"line": 13,
					"file": "ArgumentError.ts",
					"path": "src/lib/errors"
				}
			},
			"props": [
				{
					"name": "argument",
					"readonly": true,
					"type": [
						[
							["IArgument", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 10,
						"file": "ArgumentError.ts",
						"path": "src/lib/errors"
					}
				},
				{
					"name": "context",
					"description": "User-provided context.",
					"readonly": true,
					"type": [[["unknown"]]],
					"meta": {
						"line": 14,
						"file": "UserError.ts",
						"path": "src/lib/errors"
					}
				},
				{
					"name": "identifier",
					"description": "An identifier, useful to localize emitted errors.",
					"readonly": true,
					"type": [[["string"]]],
					"meta": {
						"line": 9,
						"file": "UserError.ts",
						"path": "src/lib/errors"
					}
				},
				{
					"name": "parameter",
					"readonly": true,
					"type": [[["string"]]],
					"meta": {
						"line": 11,
						"file": "ArgumentError.ts",
						"path": "src/lib/errors"
					}
				},
				{
					"name": "name",
					"readonly": true,
					"type": [[["string"]]],
					"meta": {
						"line": 20,
						"file": "ArgumentError.ts",
						"path": "src/lib/errors"
					}
				}
			],
			"meta": {
				"line": 9,
				"file": "ArgumentError.ts",
				"path": "src/lib/errors"
			}
		},
		{
			"name": "ArgumentStore",
			"extends": ["AliasStore<Argument>"],
			"construct": {
				"name": "constructor",
				"returns": [[["ArgumentStore"]]],
				"meta": {
					"line": 5,
					"file": "ArgumentStore.ts",
					"path": "src/lib/structures"
				}
			},
			"meta": {
				"line": 4,
				"file": "ArgumentStore.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "ClientPermissionsPrecondition",
			"description": "Constructs a contextful permissions precondition requirement.",
			"see": [],
			"implements": ["PreconditionSingleResolvableDetails<'ClientPermissions'>"],
			"examples": [
				"```typescript\nexport class CoreCommand extends Command {\n  public constructor(context: PieceContext) {\n    super(context, {\n      preconditions: [\n        'GuildOnly',\n        new ClientPermissionsPrecondition('ADD_REACTIONS')\n      ]\n    });\n  }\n\n  public messageRun(message: Message, args: Args) {\n    // ...\n  }\n}\n```"
			],
			"abstract": false,
			"deprecated": false,
			"construct": {
				"name": "constructor",
				"description": "Constructs a precondition container entry.",
				"params": [
					{
						"name": "permissions",
						"description": "The permissions that will be required by this command.",
						"optional": false,
						"type": [[["PermissionResolvable"]]]
					}
				],
				"returns": [[["ClientPermissionsPrecondition"]]],
				"meta": {
					"line": 33,
					"file": "ClientPermissionsPrecondition.ts",
					"path": "src/lib/utils/preconditions/containers"
				}
			},
			"props": [
				{
					"name": "context",
					"description": "The context to be set at {@link PreconditionContainerSingle.context}.",
					"type": [[["{"], ["\npermissions", ": "], ["Permissions\n", "}"]]],
					"meta": {
						"line": 27,
						"file": "ClientPermissionsPrecondition.ts",
						"path": "src/lib/utils/preconditions/containers"
					}
				},
				{
					"name": "name",
					"description": "The name of the precondition to retrieve from {@link SapphireClient.preconditions}.",
					"type": [[["'ClientPermissions'"]]],
					"meta": {
						"line": 26,
						"file": "ClientPermissionsPrecondition.ts",
						"path": "src/lib/utils/preconditions/containers"
					}
				}
			],
			"meta": {
				"line": 25,
				"file": "ClientPermissionsPrecondition.ts",
				"path": "src/lib/utils/preconditions/containers"
			}
		},
		{
			"name": "Command",
			"extends": ["AliasPiece<O>"],
			"construct": {
				"name": "constructor",
				"see": [],
				"examples": [],
				"abstract": false,
				"deprecated": false,
				"emits": [],
				"params": [
					{
						"name": "context",
						"description": "The context.",
						"optional": false,
						"type": [[["PieceContext"]]]
					},
					{
						"name": "options",
						"description": "Optional Command settings.",
						"optional": true,
						"default": "{}",
						"type": [[["CommandOptions"]]]
					}
				],
				"returns": [
					[
						["Command", "<"],
						["T", ", "],
						["O", ">"]
					]
				],
				"meta": {
					"line": 64,
					"file": "Command.ts",
					"path": "src/lib/structures"
				}
			},
			"props": [
				{
					"name": "description",
					"description": "A basic summary about the command",
					"see": [],
					"abstract": false,
					"deprecated": false,
					"type": [[["string"]]],
					"meta": {
						"line": 15,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "detailedDescription",
					"description": "Longer version of command's summary and how to use it",
					"see": [],
					"abstract": false,
					"deprecated": false,
					"type": [[["string"]]],
					"meta": {
						"line": 27,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "fullCategory",
					"description": "The full category for the command. Either an array of strings that denote every (sub)folder the command is in,\nor `null` if it could not be resolved automatically.",
					"extendedDescription": "If this is `null` for how you setup your code then you can overwrite how the `fullCategory` is resolved by\nextending this class and overwriting the assignment in the constructor.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [
						[
							["readonly", " "],
							["Array", "<"],
							["string", ">"]
						]
					],
					"meta": {
						"line": 37,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "lexer",
					"description": "The lexer to be used for command parsing",
					"see": [],
					"access": "private",
					"abstract": false,
					"deprecated": false,
					"type": [[["Lexer"]]],
					"meta": {
						"line": 57,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "preconditions",
					"description": "The preconditions to be run.",
					"see": [],
					"abstract": false,
					"deprecated": false,
					"type": [[["PreconditionContainerArray"]]],
					"meta": {
						"line": 21,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "strategy",
					"description": "The strategy to use for the lexer.",
					"see": [],
					"abstract": false,
					"deprecated": false,
					"type": [[["UnorderedStrategy"]]],
					"meta": {
						"line": 43,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "typing",
					"description": "If {@link SapphireClient.typing} is true, it can be overridden for a specific command using this property, set via its options.\nOtherwise, this property will be ignored.",
					"see": [],
					"abstract": false,
					"deprecated": false,
					"default": "true",
					"type": [[["boolean"]]],
					"meta": {
						"line": 50,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "category",
					"description": "The main category for the command, if any.",
					"extendedDescription": "This getter retrieves the first value of {@link Command.fullCategory}, if it has at least one item, otherwise it\nreturns `null`.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [[["null", " | "], ["string"]]],
					"meta": {
						"line": 122,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "parentCategory",
					"description": "The parent category for the command.",
					"extendedDescription": "This getter retrieves the last value of {@link Command.fullCategory}, if it has at least one item, otherwise it\nreturns `null`.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [[["null", " | "], ["string"]]],
					"meta": {
						"line": 146,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "subCategory",
					"description": "The sub-category for the command, if any.",
					"extendedDescription": "This getter retrieves the second value of {@link Command.fullCategory}, if it has at least two items, otherwise\nit returns `null`.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [[["null", " | "], ["string"]]],
					"meta": {
						"line": 134,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"methods": [
				{
					"name": "messageRun",
					"description": "Executes the command's logic for a message.",
					"params": [
						{
							"name": "message",
							"description": "The message that triggered the command.",
							"optional": false,
							"type": [
								[
									["Message", "<"],
									["boolean", ">"]
								]
							]
						},
						{
							"name": "args",
							"description": "The value returned by {@link Command.preParse}, by default an instance of {@link Args}.",
							"optional": false,
							"type": [[["T"]]]
						},
						{
							"name": "context",
							"optional": false,
							"type": [[["CommandContext"]]]
						}
					],
					"returns": [[["unknown"]]],
					"meta": {
						"line": 155,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "parseConstructorPreConditions",
					"description": "Parses the command's options and processes them, calling {@link Command#parseConstructorPreConditionsRunIn},\n{@link Command#parseConstructorPreConditionsNsfw},\n{@link Command#parseConstructorPreConditionsRequiredClientPermissions}, and\n{@link Command#parseConstructorPreConditionsCooldown}.",
					"see": [],
					"examples": [],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "options",
							"description": "The command options given from the constructor.",
							"optional": false,
							"type": [[["CommandOptions"]]]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 177,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "parseConstructorPreConditionsCooldown",
					"description": "Appends the `Cooldown` precondition when {@link Command.Options.cooldownLimit} and\n{@link Command.Options.cooldownDelay} are both non-zero.",
					"params": [
						{
							"name": "options",
							"description": "The command options given from the constructor.",
							"optional": false,
							"type": [[["CommandOptions"]]]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 233,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "parseConstructorPreConditionsNsfw",
					"description": "Appends the `NSFW` precondition if {@link Command.Options.nsfw} is set to true.",
					"params": [
						{
							"name": "options",
							"description": "The command options given from the constructor.",
							"optional": false,
							"type": [[["CommandOptions"]]]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 189,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "parseConstructorPreConditionsRequiredClientPermissions",
					"description": "Appends the `ClientPermissions` precondition when {@link Command.Options.requiredClientPermissions} resolves to a\nnon-zero bitfield.",
					"params": [
						{
							"name": "options",
							"description": "The command options given from the constructor.",
							"optional": false,
							"type": [[["CommandOptions"]]]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 209,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "parseConstructorPreConditionsRequiredUserPermissions",
					"description": "Appends the `UserPermissions` precondition when {@link Command.Options.requiredUserPermissions} resolves to a\nnon-zero bitfield.",
					"params": [
						{
							"name": "options",
							"description": "The command options given from the constructor.",
							"optional": false,
							"type": [[["CommandOptions"]]]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 221,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "parseConstructorPreConditionsRunIn",
					"description": "Appends the `DMOnly`, `GuildOnly`, `NewsOnly`, and `TextOnly` preconditions based on the values passed in\n{@link Command.Options.runIn}, optimizing in specific cases (`NewsOnly` + `TextOnly` = `GuildOnly`; `DMOnly` +\n`GuildOnly` = `null`), defaulting to `null`, which doesn't add a precondition.",
					"params": [
						{
							"name": "options",
							"description": "The command options given from the constructor.",
							"optional": false,
							"type": [[["CommandOptions"]]]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 199,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "preParse",
					"description": "The pre-parse method. This method can be overridden by plugins to define their own argument parser.",
					"params": [
						{
							"name": "message",
							"description": "The message that triggered the command.",
							"optional": false,
							"type": [
								[
									["Message", "<"],
									["boolean", ">"]
								]
							]
						},
						{
							"name": "parameters",
							"description": "The raw parameters as a single string.",
							"optional": false,
							"type": [[["string"]]]
						},
						{
							"name": "context",
							"description": "The command-context used in this execution.",
							"optional": false,
							"type": [[["CommandContext"]]]
						}
					],
					"returns": [
						[
							["Awaitable", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 108,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "resolveConstructorPreConditionsRunType",
					"access": "private",
					"params": [
						{
							"name": "runIn",
							"optional": false,
							"type": [
								[
									["undefined", " | "],
									["null", " | "],
									["CommandOptionsRunType", " | "],
									["CommandOptionsRunTypeEnum", " | "],
									["readonly", " "],
									["Array", "<"],
									["CommandOptionsRunType", " | "],
									["CommandOptionsRunTypeEnum", ">"]
								]
							]
						}
					],
					"returns": [[["null", " | "], ["PreconditionContainerArray", " | "], ["CommandPreConditions"]]],
					"meta": {
						"line": 253,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "run",
					"description": "Executes the command's logic.",
					"see": [],
					"examples": [],
					"abstract": false,
					"deprecated": true,
					"emits": [],
					"params": [
						{
							"name": "message",
							"description": "The message that triggered the command.",
							"optional": false,
							"type": [
								[
									["Message", "<"],
									["boolean", ">"]
								]
							]
						},
						{
							"name": "args",
							"description": "The value returned by {@link Command.preParse}, by default an instance of {@link Args}.",
							"optional": false,
							"type": [[["T"]]]
						},
						{
							"name": "context",
							"optional": false,
							"type": [[["CommandContext"]]]
						}
					],
					"returns": [[["unknown"]]]
				},
				{
					"name": "toJSON",
					"description": "Defines the JSON.stringify behavior of the command.",
					"returns": [[["CommandJSON"]]],
					"meta": {
						"line": 160,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"meta": {
				"line": 10,
				"file": "Command.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "CommandStore",
			"description": "Stores all Command pieces",
			"see": [],
			"extends": ["AliasStore<Command>"],
			"examples": [],
			"abstract": false,
			"deprecated": false,
			"construct": {
				"name": "constructor",
				"returns": [[["CommandStore"]]],
				"meta": {
					"line": 9,
					"file": "CommandStore.ts",
					"path": "src/lib/structures"
				}
			},
			"props": [
				{
					"name": "categories",
					"description": "Get all the command categories.",
					"readonly": true,
					"type": [
						[
							["Array", "<"],
							["string", ">"]
						]
					],
					"meta": {
						"line": 16,
						"file": "CommandStore.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"meta": {
				"line": 8,
				"file": "CommandStore.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "ExtendedArgument",
			"see": [],
			"extends": ["Argument<T>"],
			"examples": [
				"```typescript\nimport { ApplyOptions } from '@sapphire/decorators';\nimport { ExtendedArgument, ExtendedArgumentContext, ExtendedArgumentOptions } from '@sapphire/framework';\nimport type { Channel, TextChannel } from 'discord.js';\n\n(at)ApplyOptions<ExtendedArgumentOptions>({\n  name: 'textChannel',\n  baseArgument: 'channel'\n})\nexport class TextChannelArgument extends ExtendedArgument<'channel', TextChannel> {\n  public handle(parsed: Channel, { argument }: ExtendedArgumentContext): Argument.Result<TextChannel> {\n    return parsed.type === 'text'\n      ? this.ok(parsed as TextChannel)\n      : this.error({ identifier: 'ArgumentTextChannelInvalidTextChannel', message: 'The argument did not resolve to a text channel.' });\n  }\n}\n```"
			],
			"abstract": false,
			"deprecated": true,
			"construct": {
				"name": "constructor",
				"see": [],
				"examples": [],
				"abstract": false,
				"deprecated": true,
				"emits": [],
				"params": [
					{
						"name": "context",
						"optional": false,
						"type": [[["PieceContext"]]]
					},
					{
						"name": "options",
						"optional": false,
						"type": [
							[
								["ExtendedArgumentOptions", "<"],
								["K", ">"]
							]
						]
					}
				],
				"returns": [
					[
						["ExtendedArgument", "<"],
						["K", ", "],
						["T", ">"]
					]
				],
				"meta": {
					"line": 41,
					"file": "ExtendedArgument.ts",
					"path": "src/lib/structures"
				}
			},
			"props": [
				{
					"name": "baseArgument",
					"type": [[["K"]]],
					"meta": {
						"line": 36,
						"file": "ExtendedArgument.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "base",
					"description": "Represents the underlying argument that transforms the raw argument\ninto the value used to compute the extended argument's value.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": true,
					"type": [
						[
							["IArgument", "<"],
							["ArgType", "["],
							["K", "]>"]
						]
					],
					"meta": {
						"line": 51,
						"file": "ExtendedArgument.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"methods": [
				{
					"name": "error",
					"description": "Constructs an {@link ArgumentError} with a custom type.",
					"params": [
						{
							"name": "options",
							"optional": false,
							"type": [
								[
									["Omit", "<"],
									["Options", "<"],
									["T", ">, "],
									["'argument'", ">"]
								]
							]
						}
					],
					"returns": [
						[
							["Result", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 83,
						"file": "Argument.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "handle",
					"see": [],
					"examples": [],
					"abstract": false,
					"deprecated": true,
					"emits": [],
					"params": [
						{
							"name": "parsed",
							"optional": false,
							"type": [
								[
									["ArgType", "["],
									["K", "]"]
								]
							]
						},
						{
							"name": "context",
							"optional": false,
							"type": [[["ExtendedArgumentContext"]]]
						}
					],
					"returns": [
						[
							["Result", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 69,
						"file": "ExtendedArgument.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "ok",
					"description": "Wraps a value into a successful value.",
					"params": [
						{
							"name": "value",
							"description": "The value to wrap.",
							"optional": false,
							"type": [[["T"]]]
						}
					],
					"returns": [
						[
							["Result", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 73,
						"file": "Argument.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "run",
					"see": [],
					"examples": [],
					"abstract": false,
					"deprecated": true,
					"emits": [],
					"params": [
						{
							"name": "parameter",
							"optional": false,
							"type": [[["string"]]]
						},
						{
							"name": "context",
							"optional": false,
							"type": [
								[
									["Context", "<"],
									["T", ">"]
								]
							]
						}
					],
					"returns": [
						[
							["AsyncResult", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 58,
						"file": "ExtendedArgument.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"meta": {
				"line": 35,
				"file": "ExtendedArgument.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "Listener",
			"description": "The base event class. This class is abstract and is to be extended by subclasses, which should implement the methods. In\nSapphire's workflow, listeners are called when the emitter they listen on emits a new message with the same event name.",
			"see": [],
			"extends": ["Piece<O>"],
			"examples": [
				"```typescript\nimport { Events, Listener } from '@sapphire/framework';\n\nexport class CoreListener extends Listener<typeof Events.Ready> {\n  public constructor(context: Listener.Context) {\n    super(context, { event: Events.Ready, once: true });\n  }\n\n  public run() {\n    this.container.client.id ??= this.container.client.user?.id ?? null;\n  }\n}\n```"
			],
			"abstract": false,
			"deprecated": false,
			"construct": {
				"name": "constructor",
				"params": [
					{
						"name": "context",
						"optional": false,
						"type": [[["PieceContext"]]]
					},
					{
						"name": "options",
						"optional": true,
						"default": "{}",
						"type": [[["ListenerOptions"]]]
					}
				],
				"returns": [
					[
						["Listener", "<"],
						["E", ", "],
						["O", ">"]
					]
				],
				"meta": {
					"line": 47,
					"file": "Listener.ts",
					"path": "src/lib/structures"
				}
			},
			"props": [
				{
					"name": "_listener",
					"access": "private",
					"type": [[["null", " | ("], ["args", ": "], ["Array", "<"], ["any", ">) => "], ["void"]]],
					"meta": {
						"line": 45,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "emitter",
					"description": "The emitter, if any.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [[["null", " | "], ["EventEmitter"]]],
					"meta": {
						"line": 31,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "event",
					"description": "The name of the event the listener listens to.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [[["string"]]],
					"meta": {
						"line": 37,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "once",
					"description": "Whether or not the listener will be unloaded after the first run.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [[["boolean"]]],
					"meta": {
						"line": 43,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"methods": [
				{
					"name": "_run",
					"access": "private",
					"params": [
						{
							"name": "args",
							"optional": false,
							"type": [
								[
									["Array", "<"],
									["unknown", ">"]
								]
							]
						}
					],
					"returns": [
						[
							["Promise", "<"],
							["void", ">"]
						]
					],
					"meta": {
						"line": 102,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "_runOnce",
					"access": "private",
					"params": [
						{
							"name": "args",
							"optional": false,
							"type": [
								[
									["Array", "<"],
									["unknown", ">"]
								]
							]
						}
					],
					"returns": [
						[
							["Promise", "<"],
							["void", ">"]
						]
					],
					"meta": {
						"line": 110,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "onLoad",
					"returns": [[["unknown"]]],
					"meta": {
						"line": 66,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "onUnload",
					"returns": [[["unknown"]]],
					"meta": {
						"line": 79,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "run",
					"params": [
						{
							"name": "args",
							"optional": false,
							"type": [
								[
									["E", " "],
									["extends", " "],
									["keyof", " "],
									["ClientEvents", " ? "],
									["ClientEvents", "["],
									["E", "] : "],
									["Array", "<"],
									["unknown", ">"]
								]
							]
						}
					],
					"returns": [[["unknown"]]],
					"meta": {
						"line": 64,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "toJSON",
					"returns": [[["ListenerJSON"]]],
					"meta": {
						"line": 94,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"meta": {
				"line": 26,
				"file": "Listener.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "ListenerStore",
			"extends": ["Store<Listener>"],
			"construct": {
				"name": "constructor",
				"returns": [[["ListenerStore"]]],
				"meta": {
					"line": 5,
					"file": "ListenerStore.ts",
					"path": "src/lib/structures"
				}
			},
			"meta": {
				"line": 4,
				"file": "ListenerStore.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "Logger",
			"implements": ["ILogger"],
			"construct": {
				"name": "constructor",
				"params": [
					{
						"name": "level",
						"optional": false,
						"type": [[["LogLevel"]]]
					}
				],
				"returns": [[["Logger"]]],
				"meta": {
					"line": 6,
					"file": "Logger.ts",
					"path": "src/lib/utils/logger"
				}
			},
			"props": [
				{
					"name": "level",
					"type": [[["LogLevel"]]],
					"meta": {
						"line": 4,
						"file": "Logger.ts",
						"path": "src/lib/utils/logger"
					}
				},
				{
					"name": "levels",
					"scope": "static",
					"readonly": true,
					"type": [
						[
							["Map", "<"],
							["LogLevel", ", "],
							["LogMethods", ">"]
						]
					],
					"meta": {
						"line": 44,
						"file": "Logger.ts",
						"path": "src/lib/utils/logger"
					}
				}
			],
			"methods": [
				{
					"name": "debug",
					"description": "Alias of {@link ILogger.write} with {@link LogLevel.Debug} as level.",
					"params": [
						{
							"name": "values",
							"optional": false,
							"type": [
								[
									["readonly", " "],
									["Array", "<"],
									["unknown", ">"]
								]
							]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 18,
						"file": "Logger.ts",
						"path": "src/lib/utils/logger"
					}
				},
				{
					"name": "error",
					"description": "Alias of {@link ILogger.write} with {@link LogLevel.Error} as level.",
					"params": [
						{
							"name": "values",
							"optional": false,
							"type": [
								[
									["readonly", " "],
									["Array", "<"],
									["unknown", ">"]
								]
							]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 30,
						"file": "Logger.ts",
						"path": "src/lib/utils/logger"
					}
				},
				{
					"name": "fatal",
					"description": "Alias of {@link ILogger.write} with {@link LogLevel.Fatal} as level.",
					"params": [
						{
							"name": "values",
							"optional": false,
							"type": [
								[
									["readonly", " "],
									["Array", "<"],
									["unknown", ">"]
								]
							]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 34,
						"file": "Logger.ts",
						"path": "src/lib/utils/logger"
					}
				},
				{
					"name": "has",
					"description": "Checks whether a level is supported.",
					"params": [
						{
							"name": "level",
							"optional": false,
							"type": [[["LogLevel"]]]
						}
					],
					"returns": [[["boolean"]]],
					"meta": {
						"line": 10,
						"file": "Logger.ts",
						"path": "src/lib/utils/logger"
					}
				},
				{
					"name": "info",
					"description": "Alias of {@link ILogger.write} with {@link LogLevel.Info} as level.",
					"params": [
						{
							"name": "values",
							"optional": false,
							"type": [
								[
									["readonly", " "],
									["Array", "<"],
									["unknown", ">"]
								]
							]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 22,
						"file": "Logger.ts",
						"path": "src/lib/utils/logger"
					}
				},
				{
					"name": "trace",
					"description": "Alias of {@link ILogger.write} with {@link LogLevel.Trace} as level.",
					"params": [
						{
							"name": "values",
							"optional": false,
							"type": [
								[
									["readonly", " "],
									["Array", "<"],
									["unknown", ">"]
								]
							]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 14,
						"file": "Logger.ts",
						"path": "src/lib/utils/logger"
					}
				},
				{
					"name": "warn",
					"description": "Alias of {@link ILogger.write} with {@link LogLevel.Warn} as level.",
					"params": [
						{
							"name": "values",
							"optional": false,
							"type": [
								[
									["readonly", " "],
									["Array", "<"],
									["unknown", ">"]
								]
							]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 26,
						"file": "Logger.ts",
						"path": "src/lib/utils/logger"
					}
				},
				{
					"name": "write",
					"description": "Writes the log message given a level and the value(s).",
					"params": [
						{
							"name": "level",
							"optional": false,
							"type": [[["LogLevel"]]]
						},
						{
							"name": "values",
							"optional": false,
							"type": [
								[
									["readonly", " "],
									["Array", "<"],
									["unknown", ">"]
								]
							]
						}
					],
					"returns": [[["void"]]],
					"meta": {
						"line": 38,
						"file": "Logger.ts",
						"path": "src/lib/utils/logger"
					}
				}
			],
			"meta": {
				"line": 3,
				"file": "Logger.ts",
				"path": "src/lib/utils/logger"
			}
		},
		{
			"name": "Plugin",
			"construct": {
				"name": "constructor",
				"returns": [[["Plugin"]]]
			},
			"props": [
				{
					"name": "[postInitialization]",
					"scope": "static",
					"type": [[["("], ["options", ": "], ["ClientOptions", ") => "], ["void"]]],
					"meta": {
						"line": 10,
						"file": "Plugin.ts",
						"path": "src/lib/plugins"
					}
				},
				{
					"name": "[postLogin]",
					"scope": "static",
					"type": [[["("], ["options", ": "], ["ClientOptions", ") => "], ["Awaitable", "<"], ["void", ">"]]],
					"meta": {
						"line": 12,
						"file": "Plugin.ts",
						"path": "src/lib/plugins"
					}
				},
				{
					"name": "[preGenericsInitialization]",
					"scope": "static",
					"type": [[["("], ["options", ": "], ["ClientOptions", ") => "], ["void"]]],
					"meta": {
						"line": 8,
						"file": "Plugin.ts",
						"path": "src/lib/plugins"
					}
				},
				{
					"name": "[preInitialization]",
					"scope": "static",
					"type": [[["("], ["options", ": "], ["ClientOptions", ") => "], ["void"]]],
					"meta": {
						"line": 9,
						"file": "Plugin.ts",
						"path": "src/lib/plugins"
					}
				},
				{
					"name": "[preLogin]",
					"scope": "static",
					"type": [[["("], ["options", ": "], ["ClientOptions", ") => "], ["Awaitable", "<"], ["void", ">"]]],
					"meta": {
						"line": 11,
						"file": "Plugin.ts",
						"path": "src/lib/plugins"
					}
				}
			],
			"meta": {
				"line": 7,
				"file": "Plugin.ts",
				"path": "src/lib/plugins"
			}
		},
		{
			"name": "PluginManager",
			"construct": {
				"name": "constructor",
				"returns": [[["PluginManager"]]]
			},
			"props": [
				{
					"name": "registry",
					"readonly": true,
					"type": [
						[
							["Set", "<"],
							["SapphirePluginHookEntry", "<"],
							["SapphirePluginAsyncHook", " | "],
							["SapphirePluginHook", ">>"]
						]
					],
					"meta": {
						"line": 25,
						"file": "PluginManager.ts",
						"path": "src/lib/plugins"
					}
				}
			],
			"methods": [
				{
					"name": "registerHook",
					"params": [
						{
							"name": "hook",
							"optional": false,
							"type": [[["SapphirePluginHook"]]]
						},
						{
							"name": "type",
							"optional": false,
							"type": [[["SyncPluginHooks"]]]
						},
						{
							"name": "name",
							"optional": true,
							"type": [[["string"]]]
						}
					],
					"returns": [[["PluginManager"]]],
					"meta": {
						"line": 27,
						"file": "PluginManager.ts",
						"path": "src/lib/plugins"
					}
				},
				{
					"name": "registerPostInitializationHook",
					"params": [
						{
							"name": "hook",
							"optional": false,
							"type": [[["SapphirePluginHook"]]]
						},
						{
							"name": "name",
							"optional": true,
							"type": [[["string"]]]
						}
					],
					"returns": [[["PluginManager"]]],
					"meta": {
						"line": 43,
						"file": "PluginManager.ts",
						"path": "src/lib/plugins"
					}
				},
				{
					"name": "registerPostLoginHook",
					"params": [
						{
							"name": "hook",
							"optional": false,
							"type": [[["SapphirePluginAsyncHook"]]]
						},
						{
							"name": "name",
							"optional": true,
							"type": [[["string"]]]
						}
					],
					"returns": [[["PluginManager"]]],
					"meta": {
						"line": 51,
						"file": "PluginManager.ts",
						"path": "src/lib/plugins"
					}
				},
				{
					"name": "registerPreGenericsInitializationHook",
					"params": [
						{
							"name": "hook",
							"optional": false,
							"type": [[["SapphirePluginHook"]]]
						},
						{
							"name": "name",
							"optional": true,
							"type": [[["string"]]]
						}
					],
					"returns": [[["PluginManager"]]],
					"meta": {
						"line": 35,
						"file": "PluginManager.ts",
						"path": "src/lib/plugins"
					}
				},
				{
					"name": "registerPreInitializationHook",
					"params": [
						{
							"name": "hook",
							"optional": false,
							"type": [[["SapphirePluginHook"]]]
						},
						{
							"name": "name",
							"optional": true,
							"type": [[["string"]]]
						}
					],
					"returns": [[["PluginManager"]]],
					"meta": {
						"line": 39,
						"file": "PluginManager.ts",
						"path": "src/lib/plugins"
					}
				},
				{
					"name": "registerPreLoginHook",
					"params": [
						{
							"name": "hook",
							"optional": false,
							"type": [[["SapphirePluginAsyncHook"]]]
						},
						{
							"name": "name",
							"optional": true,
							"type": [[["string"]]]
						}
					],
					"returns": [[["PluginManager"]]],
					"meta": {
						"line": 47,
						"file": "PluginManager.ts",
						"path": "src/lib/plugins"
					}
				},
				{
					"name": "use",
					"params": [
						{
							"name": "plugin",
							"optional": false,
							"type": [[["("], ["typeof", " "], ["Plugin", ")"]]]
						}
					],
					"returns": [[["PluginManager"]]],
					"meta": {
						"line": 55,
						"file": "PluginManager.ts",
						"path": "src/lib/plugins"
					}
				},
				{
					"name": "values",
					"returns": [
						[
							["Generator", "<"],
							["SapphirePluginHookEntry", "<"],
							["SapphirePluginAsyncHook", " | "],
							["SapphirePluginHook", ">, "],
							["void", ", "],
							["unknown", ">"]
						]
					],
					"meta": {
						"line": 71,
						"file": "PluginManager.ts",
						"path": "src/lib/plugins"
					}
				}
			],
			"meta": {
				"line": 24,
				"file": "PluginManager.ts",
				"path": "src/lib/plugins"
			}
		},
		{
			"name": "Precondition",
			"extends": ["Piece<O>"],
			"construct": {
				"name": "constructor",
				"params": [
					{
						"name": "context",
						"optional": false,
						"type": [[["PieceContext"]]]
					},
					{
						"name": "options",
						"optional": true,
						"default": "{}",
						"type": [[["PreconditionOptions"]]]
					}
				],
				"returns": [
					[
						["Precondition", "<"],
						["O", ">"]
					]
				],
				"meta": {
					"line": 16,
					"file": "Precondition.ts",
					"path": "src/lib/structures"
				}
			},
			"props": [
				{
					"name": "position",
					"readonly": true,
					"type": [[["null", " | "], ["number"]]],
					"meta": {
						"line": 14,
						"file": "Precondition.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"methods": [
				{
					"name": "error",
					"description": "Constructs a {@link PreconditionError} with the precondition parameter set to `this`.",
					"params": [
						{
							"name": "options",
							"description": "The information.",
							"optional": true,
							"default": "{}",
							"type": [
								[
									["Omit", "<"],
									["Options", ", "],
									["'precondition'", ">"]
								]
							]
						}
					],
					"returns": [[["PreconditionResult"]]],
					"meta": {
						"line": 31,
						"file": "Precondition.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "ok",
					"returns": [[["PreconditionResult"]]],
					"meta": {
						"line": 23,
						"file": "Precondition.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "run",
					"params": [
						{
							"name": "message",
							"optional": false,
							"type": [
								[
									["Message", "<"],
									["boolean", ">"]
								]
							]
						},
						{
							"name": "command",
							"optional": false,
							"type": [
								[
									["Command", "<"],
									["Args", ", "],
									["CommandOptions", ">"]
								]
							]
						},
						{
							"name": "context",
							"optional": false,
							"type": [[["PreconditionContext"]]]
						}
					],
					"returns": [[["PreconditionResult"]]],
					"meta": {
						"line": 21,
						"file": "Precondition.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"meta": {
				"line": 13,
				"file": "Precondition.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "PreconditionContainerArray",
			"description": "An {@link IPreconditionContainer} that defines an array of multiple {@link IPreconditionContainer}s.",
			"extendedDescription": "By default, array containers run either of two conditions: AND and OR ({@link PreconditionRunCondition}), the top level\nwill always default to AND, where the nested one flips the logic (OR, then children arrays are AND, then OR...).\n\nThis allows `['Connect', ['Moderator', ['DJ', 'SongAuthor']]]` to become a thrice-nested precondition container, where:\n- Level 1: [Single(Connect), Array] runs AND, both containers must return a successful value.\n- Level 2: [Single(Moderator), Array] runs OR, either container must return a successful value.\n- Level 3: [Single(DJ), Single(SongAuthor)] runs AND, both containers must return a successful value.\n\nIn other words, it is identical to doing:\n```typescript\nConnect && (Moderator || (DJ && SongAuthor));\n```",
			"see": [],
			"implements": ["IPreconditionContainer"],
			"examples": [],
			"abstract": false,
			"deprecated": false,
			"construct": {
				"name": "constructor",
				"params": [
					{
						"name": "data",
						"optional": true,
						"default": "[]",
						"type": [[["PreconditionArrayResolvable"]]]
					},
					{
						"name": "parent",
						"optional": true,
						"default": "null",
						"type": [[["null", " | "], ["PreconditionContainerArray"]]]
					}
				],
				"returns": [[["PreconditionContainerArray"]]],
				"meta": {
					"line": 127,
					"file": "PreconditionContainerArray.ts",
					"path": "src/lib/utils/preconditions"
				}
			},
			"props": [
				{
					"name": "entries",
					"description": "The {@link IPreconditionContainer}s the array holds.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [
						[
							["Array", "<"],
							["IPreconditionContainer", ">"]
						]
					],
					"meta": {
						"line": 119,
						"file": "PreconditionContainerArray.ts",
						"path": "src/lib/utils/preconditions"
					}
				},
				{
					"name": "mode",
					"description": "The mode at which this precondition will run.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [[["PreconditionRunMode"]]],
					"meta": {
						"line": 113,
						"file": "PreconditionContainerArray.ts",
						"path": "src/lib/utils/preconditions"
					}
				},
				{
					"name": "runCondition",
					"description": "The {@link PreconditionRunCondition} that defines how entries must be handled.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [[["PreconditionRunCondition"]]],
					"meta": {
						"line": 125,
						"file": "PreconditionContainerArray.ts",
						"path": "src/lib/utils/preconditions"
					}
				},
				{
					"name": "conditions",
					"description": "The preconditions to be run. Extra ones can be added by augmenting {@link PreconditionRunCondition} and then\ninserting {@link IPreconditionCondition}s.",
					"see": [],
					"scope": "static",
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [
						[
							["Collection", "<"],
							["PreconditionRunCondition", ", "],
							["IPreconditionCondition", ">"]
						]
					],
					"meta": {
						"line": 219,
						"file": "PreconditionContainerArray.ts",
						"path": "src/lib/utils/preconditions"
					}
				},
				{
					"name": "condition",
					"description": "Retrieves a condition from {@link PreconditionContainerArray.conditions}, assuming existence.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [[["IPreconditionCondition"]]],
					"meta": {
						"line": 194,
						"file": "PreconditionContainerArray.ts",
						"path": "src/lib/utils/preconditions"
					}
				}
			],
			"methods": [
				{
					"name": "add",
					"description": "Adds a new entry to the array.",
					"see": [],
					"examples": [],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "entry",
							"description": "The value to add to the entries.",
							"optional": false,
							"type": [[["IPreconditionContainer"]]]
						}
					],
					"returns": [[["PreconditionContainerArray"]]],
					"meta": {
						"line": 149,
						"file": "PreconditionContainerArray.ts",
						"path": "src/lib/utils/preconditions"
					}
				},
				{
					"name": "append",
					"params": [
						{
							"name": "keyOrEntries",
							"optional": false,
							"type": [
								[
									["PreconditionContainerArray", " | "],
									["SimplePreconditionKeys", " | "],
									["SimplePreconditionSingleResolvableDetails"]
								]
							]
						}
					],
					"returns": [[["PreconditionContainerArray"]]],
					"meta": {
						"line": 154,
						"file": "PreconditionContainerArray.ts",
						"path": "src/lib/utils/preconditions"
					}
				},
				{
					"name": "parse",
					"description": "Parses the precondition entry resolvables, and adds them to the entries.",
					"see": [],
					"examples": [],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "entries",
							"description": "The entries to parse.",
							"optional": false,
							"type": [
								[
									["Iterable", "<"],
									["PreconditionEntryResolvable", ">"]
								]
							]
						}
					],
					"returns": [[["PreconditionContainerArray"]]],
					"meta": {
						"line": 178,
						"file": "PreconditionContainerArray.ts",
						"path": "src/lib/utils/preconditions"
					}
				},
				{
					"name": "run",
					"description": "Runs the container.",
					"see": [],
					"examples": [],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "message",
							"description": "The message that ran this precondition.",
							"optional": false,
							"type": [
								[
									["Message", "<"],
									["boolean", ">"]
								]
							]
						},
						{
							"name": "command",
							"description": "The command the message invoked.",
							"optional": false,
							"type": [
								[
									["Command", "<"],
									["Args", ", "],
									["CommandOptions", ">"]
								]
							]
						},
						{
							"name": "context",
							"optional": true,
							"default": "{}",
							"type": [[["PreconditionContext"]]]
						}
					],
					"returns": [[["PreconditionContainerReturn"]]],
					"meta": {
						"line": 167,
						"file": "PreconditionContainerArray.ts",
						"path": "src/lib/utils/preconditions"
					}
				}
			],
			"meta": {
				"line": 108,
				"file": "PreconditionContainerArray.ts",
				"path": "src/lib/utils/preconditions"
			}
		},
		{
			"name": "PreconditionContainerSingle",
			"description": "An {@link IPreconditionContainer} which runs a single precondition from {@link SapphireClient.preconditions}.",
			"see": [],
			"implements": ["IPreconditionContainer"],
			"examples": [],
			"abstract": false,
			"deprecated": false,
			"construct": {
				"name": "constructor",
				"params": [
					{
						"name": "data",
						"optional": false,
						"type": [[["PreconditionSingleResolvable"]]]
					}
				],
				"returns": [[["PreconditionContainerSingle"]]],
				"meta": {
					"line": 64,
					"file": "PreconditionContainerSingle.ts",
					"path": "src/lib/utils/preconditions"
				}
			},
			"props": [
				{
					"name": "context",
					"description": "The context to be used when calling {@link Precondition.run}. This will always be an empty object (`{}`) when the\ncontainer was constructed with a string, otherwise it is a direct reference to the value from\n{@link PreconditionSingleResolvableDetails.context}.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [
						[
							["Record", "<"],
							["PropertyKey", ", "],
							["unknown", ">"]
						]
					],
					"meta": {
						"line": 56,
						"file": "PreconditionContainerSingle.ts",
						"path": "src/lib/utils/preconditions"
					}
				},
				{
					"name": "name",
					"description": "The name of the precondition to run.",
					"see": [],
					"readonly": true,
					"abstract": false,
					"deprecated": false,
					"type": [[["string"]]],
					"meta": {
						"line": 62,
						"file": "PreconditionContainerSingle.ts",
						"path": "src/lib/utils/preconditions"
					}
				}
			],
			"methods": [
				{
					"name": "run",
					"description": "Runs the container.",
					"see": [],
					"examples": [],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "message",
							"description": "The message that ran this precondition.",
							"optional": false,
							"type": [
								[
									["Message", "<"],
									["boolean", ">"]
								]
							]
						},
						{
							"name": "command",
							"description": "The command the message invoked.",
							"optional": false,
							"type": [
								[
									["Command", "<"],
									["Args", ", "],
									["CommandOptions", ">"]
								]
							]
						},
						{
							"name": "context",
							"optional": true,
							"default": "{}",
							"type": [[["PreconditionContext"]]]
						}
					],
					"returns": [[["PreconditionResult"]]],
					"meta": {
						"line": 80,
						"file": "PreconditionContainerSingle.ts",
						"path": "src/lib/utils/preconditions"
					}
				}
			],
			"meta": {
				"line": 49,
				"file": "PreconditionContainerSingle.ts",
				"path": "src/lib/utils/preconditions"
			}
		},
		{
			"name": "PreconditionError",
			"description": "Errors thrown by preconditions",
			"see": [],
			"extends": ["UserError"],
			"examples": [],
			"abstract": false,
			"deprecated": false,
			"construct": {
				"name": "constructor",
				"description": "Constructs an UserError.",
				"params": [
					{
						"name": "options",
						"optional": false,
						"type": [[["Options"]]]
					}
				],
				"returns": [[["PreconditionError"]]],
				"meta": {
					"line": 11,
					"file": "PreconditionError.ts",
					"path": "src/lib/errors"
				}
			},
			"props": [
				{
					"name": "context",
					"description": "User-provided context.",
					"readonly": true,
					"type": [[["unknown"]]],
					"meta": {
						"line": 14,
						"file": "UserError.ts",
						"path": "src/lib/errors"
					}
				},
				{
					"name": "identifier",
					"description": "An identifier, useful to localize emitted errors.",
					"readonly": true,
					"type": [[["string"]]],
					"meta": {
						"line": 9,
						"file": "UserError.ts",
						"path": "src/lib/errors"
					}
				},
				{
					"name": "precondition",
					"readonly": true,
					"type": [
						[
							["Precondition", "<"],
							["PreconditionOptions", ">"]
						]
					],
					"meta": {
						"line": 9,
						"file": "PreconditionError.ts",
						"path": "src/lib/errors"
					}
				},
				{
					"name": "name",
					"readonly": true,
					"type": [[["string"]]],
					"meta": {
						"line": 17,
						"file": "PreconditionError.ts",
						"path": "src/lib/errors"
					}
				}
			],
			"meta": {
				"line": 8,
				"file": "PreconditionError.ts",
				"path": "src/lib/errors"
			}
		},
		{
			"name": "PreconditionStore",
			"extends": ["Store<Precondition>"],
			"construct": {
				"name": "constructor",
				"returns": [[["PreconditionStore"]]],
				"meta": {
					"line": 10,
					"file": "PreconditionStore.ts",
					"path": "src/lib/structures"
				}
			},
			"props": [
				{
					"name": "globalPreconditions",
					"access": "private",
					"readonly": true,
					"default": "[]",
					"type": [
						[
							["Array", "<"],
							["Precondition", "<"],
							["PreconditionOptions", ">>"]
						]
					],
					"meta": {
						"line": 8,
						"file": "PreconditionStore.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"methods": [
				{
					"name": "clear",
					"returns": [[["void"]]],
					"meta": {
						"line": 44,
						"file": "PreconditionStore.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "delete",
					"params": [
						{
							"name": "key",
							"optional": false,
							"type": [[["string"]]]
						}
					],
					"returns": [[["boolean"]]],
					"meta": {
						"line": 35,
						"file": "PreconditionStore.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "run",
					"params": [
						{
							"name": "message",
							"optional": false,
							"type": [
								[
									["Message", "<"],
									["boolean", ">"]
								]
							]
						},
						{
							"name": "command",
							"optional": false,
							"type": [
								[
									["Command", "<"],
									["Args", ", "],
									["CommandOptions", ">"]
								]
							]
						},
						{
							"name": "context",
							"optional": true,
							"default": "{}",
							"type": [[["PreconditionContext"]]]
						}
					],
					"returns": [[["AsyncPreconditionResult"]]],
					"meta": {
						"line": 14,
						"file": "PreconditionStore.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "set",
					"params": [
						{
							"name": "key",
							"optional": false,
							"type": [[["string"]]]
						},
						{
							"name": "value",
							"optional": false,
							"type": [
								[
									["Precondition", "<"],
									["PreconditionOptions", ">"]
								]
							]
						}
					],
					"returns": [[["PreconditionStore"]]],
					"meta": {
						"line": 23,
						"file": "PreconditionStore.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"meta": {
				"line": 7,
				"file": "PreconditionStore.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "SapphireClient",
			"description": "The base {@link Client} extension that makes Sapphire work. When building a Discord bot with the framework, the developer\nmust either use this class, or extend it.",
			"extendedDescription": "Sapphire also automatically detects the folders to scan for pieces, please read {@link StoreRegistry.registerPath}\nfor reference. This method is called at the start of the {@link SapphireClient.login} method.",
			"see": [
				"{@link SapphireClientOptions} for all options available to the Sapphire Client. You can also provide all of discord.js' [ClientOptions](https://discord.js.org/#/docs/main/stable/typedef/ClientOptions)"
			],
			"extends": ["Client<Ready>"],
			"examples": [
				"```typescript\nconst client = new SapphireClient({\n  presence: {\n    activity: {\n      name: 'for commands!',\n      type: 'LISTENING'\n    }\n  }\n});\n\nclient.login(process.env.DISCORD_TOKEN)\n  .catch(console.error);\n```",
				"```typescript\n// Automatically scan from a specific directory, e.g. the main\n// file is at `/home/me/bot/index.js` and all your pieces are at\n// `/home/me/bot/pieces` (e.g. `/home/me/bot/pieces/commands/MyCommand.js`):\nconst client = new SapphireClient({\n  baseUserDirectory: join(__dirname, 'pieces'),\n  // More options...\n});\n```",
				"```typescript\n// Opt-out automatic scanning:\nconst client = new SapphireClient({\n  baseUserDirectory: null,\n  // More options...\n});\n```"
			],
			"abstract": false,
			"deprecated": false,
			"construct": {
				"name": "constructor",
				"params": [
					{
						"name": "options",
						"optional": false,
						"type": [[["ClientOptions"]]]
					}
				],
				"returns": [
					[
						["SapphireClient", "<"],
						["Ready", ">"]
					]
				],
				"meta": {
					"line": 220,
					"file": "SapphireClient.ts",
					"path": "src/lib"
				}
			},
			"props": [
				{
					"name": "fetchPrefix",
					"description": "The method to be overriden by the developer.",
					"see": [],
					"abstract": false,
					"deprecated": false,
					"type": [[["SapphirePrefixHook"]]],
					"meta": {
						"line": 205,
						"file": "SapphireClient.ts",
						"path": "src/lib"
					}
				},
				{
					"name": "id",
					"description": "The client's ID, used for the user prefix.",
					"see": [],
					"abstract": false,
					"deprecated": false,
					"default": "null",
					"type": [[["null", " | "], ["string"]]],
					"meta": {
						"line": 175,
						"file": "SapphireClient.ts",
						"path": "src/lib"
					}
				},
				{
					"name": "logger",
					"description": "The logger to be used by the framework and plugins. By default, a {@link Logger} instance is used, which emits the\nmessages to the console.",
					"see": [],
					"abstract": false,
					"deprecated": false,
					"type": [[["ILogger"]]],
					"meta": {
						"line": 212,
						"file": "SapphireClient.ts",
						"path": "src/lib"
					}
				},
				{
					"name": "stores",
					"description": "The registered stores.",
					"see": [],
					"abstract": false,
					"deprecated": false,
					"type": [[["StoreRegistry"]]],
					"meta": {
						"line": 218,
						"file": "SapphireClient.ts",
						"path": "src/lib"
					}
				},
				{
					"name": "plugins",
					"scope": "static",
					"type": [[["PluginManager"]]],
					"meta": {
						"line": 291,
						"file": "SapphireClient.ts",
						"path": "src/lib"
					}
				}
			],
			"methods": [
				{
					"name": "login",
					"description": "Loads all pieces, then logs the client in, establishing a websocket connection to Discord.",
					"see": [],
					"examples": [],
					"abstract": false,
					"deprecated": false,
					"emits": [],
					"params": [
						{
							"name": "token",
							"description": "Token of the account to log in with.",
							"optional": true,
							"type": [[["string"]]]
						}
					],
					"returns": [
						[
							["Promise", "<"],
							["string", ">"]
						]
					],
					"returnsDescription": "Token of the account used.",
					"meta": {
						"line": 266,
						"file": "SapphireClient.ts",
						"path": "src/lib"
					}
				},
				{
					"name": "use",
					"scope": "static",
					"params": [
						{
							"name": "plugin",
							"optional": false,
							"type": [[["("], ["typeof", " "], ["Plugin", ")"]]]
						}
					],
					"returns": [[["("], ["typeof", " "], ["SapphireClient", ")"]]],
					"meta": {
						"line": 293,
						"file": "SapphireClient.ts",
						"path": "src/lib"
					}
				}
			],
			"meta": {
				"line": 170,
				"file": "SapphireClient.ts",
				"path": "src/lib"
			}
		},
		{
			"name": "UserError",
			"description": "The UserError class to be emitted in the pieces.",
			"see": [],
			"extends": ["Error"],
			"examples": [],
			"abstract": false,
			"deprecated": false,
			"construct": {
				"name": "constructor",
				"description": "Constructs an UserError.",
				"params": [
					{
						"name": "options",
						"optional": false,
						"type": [[["Options"]]]
					}
				],
				"returns": [[["UserError"]]],
				"meta": {
					"line": 21,
					"file": "UserError.ts",
					"path": "src/lib/errors"
				}
			},
			"props": [
				{
					"name": "context",
					"description": "User-provided context.",
					"readonly": true,
					"type": [[["unknown"]]],
					"meta": {
						"line": 14,
						"file": "UserError.ts",
						"path": "src/lib/errors"
					}
				},
				{
					"name": "identifier",
					"description": "An identifier, useful to localize emitted errors.",
					"readonly": true,
					"type": [[["string"]]],
					"meta": {
						"line": 9,
						"file": "UserError.ts",
						"path": "src/lib/errors"
					}
				},
				{
					"name": "name",
					"readonly": true,
					"type": [[["string"]]],
					"meta": {
						"line": 28,
						"file": "UserError.ts",
						"path": "src/lib/errors"
					}
				}
			],
			"meta": {
				"line": 5,
				"file": "UserError.ts",
				"path": "src/lib/errors"
			}
		},
		{
			"name": "UserPermissionsPrecondition",
			"description": "Constructs a contextful permissions precondition requirement.",
			"see": [],
			"implements": ["PreconditionSingleResolvableDetails<'UserPermissions'>"],
			"examples": [
				"```typescript\nexport class CoreCommand extends Command {\n  public constructor(context: PieceContext) {\n    super(context, {\n      preconditions: [\n        'GuildOnly',\n        new UserPermissionsPrecondition('ADD_REACTIONS')\n      ]\n    });\n  }\n\n  public messageRun(message: Message, args: Args) {\n    // ...\n  }\n}\n```"
			],
			"abstract": false,
			"deprecated": false,
			"construct": {
				"name": "constructor",
				"description": "Constructs a precondition container entry.",
				"params": [
					{
						"name": "permissions",
						"description": "The permissions that will be required by this command.",
						"optional": false,
						"type": [[["PermissionResolvable"]]]
					}
				],
				"returns": [[["UserPermissionsPrecondition"]]],
				"meta": {
					"line": 33,
					"file": "UserPermissionsPrecondition.ts",
					"path": "src/lib/utils/preconditions/containers"
				}
			},
			"props": [
				{
					"name": "context",
					"description": "The context to be set at {@link PreconditionContainerSingle.context}.",
					"type": [[["{"], ["\npermissions", ": "], ["Permissions\n", "}"]]],
					"meta": {
						"line": 27,
						"file": "UserPermissionsPrecondition.ts",
						"path": "src/lib/utils/preconditions/containers"
					}
				},
				{
					"name": "name",
					"description": "The name of the precondition to retrieve from {@link SapphireClient.preconditions}.",
					"type": [[["'UserPermissions'"]]],
					"meta": {
						"line": 26,
						"file": "UserPermissionsPrecondition.ts",
						"path": "src/lib/utils/preconditions/containers"
					}
				}
			],
			"meta": {
				"line": 25,
				"file": "UserPermissionsPrecondition.ts",
				"path": "src/lib/utils/preconditions/containers"
			}
		}
	],
	"typedefs": [
		{
			"name": "BucketScope",
			"description": "The scope the cooldown applies to.",
			"meta": {
				"line": 18,
				"file": "Enums.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "Channel",
					"description": "Per channel cooldowns.",
					"type": [[["0"]]]
				},
				{
					"name": "Global",
					"description": "Global cooldowns.",
					"type": [[["1"]]]
				},
				{
					"name": "Guild",
					"description": "Per guild cooldowns.",
					"type": [[["2"]]]
				},
				{
					"name": "User",
					"description": "Per user cooldowns.",
					"type": [[["3"]]]
				}
			]
		},
		{
			"name": "CommandOptionsRunTypeEnum",
			"description": "The allowed values for {@link Command.Options.runIn} as an enum.",
			"see": [],
			"deprecated": false,
			"meta": {
				"line": 358,
				"file": "Command.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "Dm",
					"type": [[["\"DM\""]]]
				},
				{
					"name": "GuildAny",
					"type": [[["\"GUILD_ANY\""]]]
				},
				{
					"name": "GuildNews",
					"type": [[["\"GUILD_NEWS\""]]]
				},
				{
					"name": "GuildNewsThread",
					"type": [[["\"GUILD_NEWS_THREAD\""]]]
				},
				{
					"name": "GuildPrivateThread",
					"type": [[["\"GUILD_PRIVATE_THREAD\""]]]
				},
				{
					"name": "GuildPublicThread",
					"type": [[["\"GUILD_PUBLIC_THREAD\""]]]
				},
				{
					"name": "GuildText",
					"type": [[["\"GUILD_TEXT\""]]]
				}
			]
		},
		{
			"name": "CommandPreConditions",
			"description": "The available command pre-conditions.",
			"see": [],
			"deprecated": false,
			"meta": {
				"line": 372,
				"file": "Command.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "ClientPermissions",
					"type": [[["\"ClientPermissions\""]]]
				},
				{
					"name": "Cooldown",
					"type": [[["\"Cooldown\""]]]
				},
				{
					"name": "DirectMessageOnly",
					"type": [[["\"DMOnly\""]]]
				},
				{
					"name": "GuildNewsOnly",
					"type": [[["\"GuildNewsOnly\""]]]
				},
				{
					"name": "GuildNewsThreadOnly",
					"type": [[["\"GuildNewsThreadOnly\""]]]
				},
				{
					"name": "GuildOnly",
					"type": [[["\"GuildOnly\""]]]
				},
				{
					"name": "GuildPrivateThreadOnly",
					"type": [[["\"GuildPrivateThreadOnly\""]]]
				},
				{
					"name": "GuildPublicThreadOnly",
					"type": [[["\"GuildPublicThreadOnly\""]]]
				},
				{
					"name": "GuildTextOnly",
					"type": [[["\"GuildTextOnly\""]]]
				},
				{
					"name": "GuildThreadOnly",
					"type": [[["\"GuildThreadOnly\""]]]
				},
				{
					"name": "NotSafeForWork",
					"type": [[["\"NSFW\""]]]
				},
				{
					"name": "UserPermissions",
					"type": [[["\"UserPermissions\""]]]
				}
			]
		},
		{
			"name": "CooldownLevel",
			"meta": {
				"line": 1,
				"file": "Enums.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "Author",
					"type": [[["\"author\""]]]
				},
				{
					"name": "Channel",
					"type": [[["\"channel\""]]]
				},
				{
					"name": "Guild",
					"type": [[["\"guild\""]]]
				}
			]
		},
		{
			"name": "Identifiers",
			"meta": {
				"line": 1,
				"file": "Identifiers.ts",
				"path": "src/lib/errors"
			},
			"props": [
				{
					"name": "ArgsMissing",
					"type": [[["\"argsMissing\""]]]
				},
				{
					"name": "ArgsUnavailable",
					"type": [[["\"argsUnavailable\""]]]
				},
				{
					"name": "ArgumentBooleanError",
					"type": [[["\"booleanError\""]]]
				},
				{
					"name": "ArgumentChannelError",
					"type": [[["\"channelError\""]]]
				},
				{
					"name": "ArgumentDMChannelError",
					"type": [[["\"dmChannelError\""]]]
				},
				{
					"name": "ArgumentDateError",
					"type": [[["\"dateError\""]]]
				},
				{
					"name": "ArgumentDateTooEarly",
					"type": [[["\"dateTooEarly\""]]]
				},
				{
					"name": "ArgumentDateTooFar",
					"type": [[["\"dateTooFar\""]]]
				},
				{
					"name": "ArgumentFloatError",
					"type": [[["\"floatError\""]]]
				},
				{
					"name": "ArgumentFloatTooLarge",
					"type": [[["\"floatTooLarge\""]]]
				},
				{
					"name": "ArgumentFloatTooSmall",
					"type": [[["\"floatTooSmall\""]]]
				},
				{
					"name": "ArgumentGuildCategoryChannelError",
					"type": [[["\"categoryChannelError\""]]]
				},
				{
					"name": "ArgumentGuildChannelError",
					"type": [[["\"guildChannelError\""]]]
				},
				{
					"name": "ArgumentGuildChannelMissingGuildError",
					"type": [[["\"guildChannelMissingGuildError\""]]]
				},
				{
					"name": "ArgumentGuildNewsChannelError",
					"type": [[["\"guildNewsChannelError\""]]]
				},
				{
					"name": "ArgumentGuildNewsThreadChannelError",
					"type": [[["\"guildNewsChannelError\""]]]
				},
				{
					"name": "ArgumentGuildPrivateThreadChannelError",
					"type": [[["\"guildPrivateThreadChannelError\""]]]
				},
				{
					"name": "ArgumentGuildPublicThreadChannelError",
					"type": [[["\"guildPublicThreadChannelError\""]]]
				},
				{
					"name": "ArgumentGuildStageVoiceChannelError",
					"type": [[["\"guildStageVoiceChannelError\""]]]
				},
				{
					"name": "ArgumentGuildTextChannelError",
					"type": [[["\"guildTextChannelError\""]]]
				},
				{
					"name": "ArgumentGuildThreadChannelError",
					"type": [[["\"guildThreadChannelError\""]]]
				},
				{
					"name": "ArgumentGuildVoiceChannelError",
					"type": [[["\"guildVoiceChannelError\""]]]
				},
				{
					"name": "ArgumentHyperlinkError",
					"type": [[["\"hyperlinkError\""]]]
				},
				{
					"name": "ArgumentIntegerError",
					"type": [[["\"integerError\""]]]
				},
				{
					"name": "ArgumentIntegerTooLarge",
					"type": [[["\"integerTooLarge\""]]]
				},
				{
					"name": "ArgumentIntegerTooSmall",
					"type": [[["\"integerTooSmall\""]]]
				},
				{
					"name": "ArgumentMemberError",
					"type": [[["\"memberError\""]]]
				},
				{
					"name": "ArgumentMemberMissingGuild",
					"type": [[["\"memberMissingGuild\""]]]
				},
				{
					"name": "ArgumentMessageError",
					"type": [[["\"messageError\""]]]
				},
				{
					"name": "ArgumentNumberError",
					"type": [[["\"numberError\""]]]
				},
				{
					"name": "ArgumentNumberTooLarge",
					"type": [[["\"numberTooLarge\""]]]
				},
				{
					"name": "ArgumentNumberTooSmall",
					"type": [[["\"numberTooSmall\""]]]
				},
				{
					"name": "ArgumentRoleError",
					"type": [[["\"roleError\""]]]
				},
				{
					"name": "ArgumentRoleMissingGuild",
					"type": [[["\"roleMissingGuild\""]]]
				},
				{
					"name": "ArgumentStringTooLong",
					"type": [[["\"stringTooLong\""]]]
				},
				{
					"name": "ArgumentStringTooShort",
					"type": [[["\"stringTooShort\""]]]
				},
				{
					"name": "ArgumentUserError",
					"type": [[["\"userError\""]]]
				},
				{
					"name": "CommandDisabled",
					"type": [[["\"commandDisabled\""]]]
				},
				{
					"name": "PreconditionClientPermissions",
					"type": [[["\"preconditionClientPermissions\""]]]
				},
				{
					"name": "PreconditionClientPermissionsNoClient",
					"type": [[["\"preconditionClientPermissionsNoClient\""]]]
				},
				{
					"name": "PreconditionClientPermissionsNoPermissions",
					"type": [[["\"preconditionClientPermissionsNoPermissions\""]]]
				},
				{
					"name": "PreconditionCooldown",
					"type": [[["\"preconditionCooldown\""]]]
				},
				{
					"name": "PreconditionDMOnly",
					"type": [[["\"preconditionDmOnly\""]]]
				},
				{
					"name": "PreconditionGuildNewsOnly",
					"type": [[["\"preconditionGuildNewsOnly\""]]]
				},
				{
					"name": "PreconditionGuildNewsThreadOnly",
					"type": [[["\"preconditionGuildNewsThreadOnly\""]]]
				},
				{
					"name": "PreconditionGuildOnly",
					"type": [[["\"preconditionGuildOnly\""]]]
				},
				{
					"name": "PreconditionGuildPrivateThreadOnly",
					"type": [[["\"preconditionGuildPrivateThreadOnly\""]]]
				},
				{
					"name": "PreconditionGuildPublicThreadOnly",
					"type": [[["\"preconditionGuildPublicThreadOnly\""]]]
				},
				{
					"name": "PreconditionGuildTextOnly",
					"type": [[["\"preconditionGuildTextOnly\""]]]
				},
				{
					"name": "PreconditionNSFW",
					"type": [[["\"preconditionNsfw\""]]]
				},
				{
					"name": "PreconditionThreadOnly",
					"type": [[["\"preconditionThreadOnly\""]]]
				},
				{
					"name": "PreconditionUserPermissions",
					"type": [[["\"preconditionUserPermissions\""]]]
				},
				{
					"name": "PreconditionUserPermissionsNoPermissions",
					"type": [[["\"preconditionUserPermissionsNoPermissions\""]]]
				}
			]
		},
		{
			"name": "LogLevel",
			"description": "The logger levels for the {@link ILogger}.",
			"meta": {
				"line": 4,
				"file": "ILogger.ts",
				"path": "src/lib/utils/logger"
			},
			"props": [
				{
					"name": "Debug",
					"description": "The debug level, used when calling {@link ILogger.debug}.",
					"type": [[["20"]]]
				},
				{
					"name": "Error",
					"description": "The error level, used when calling {@link ILogger.error}.",
					"type": [[["50"]]]
				},
				{
					"name": "Fatal",
					"description": "The critical level, used when calling {@link ILogger.fatal}.",
					"type": [[["60"]]]
				},
				{
					"name": "Info",
					"description": "The info level, used when calling {@link ILogger.info}.",
					"type": [[["30"]]]
				},
				{
					"name": "None",
					"description": "An unknown or uncategorized level.",
					"type": [[["100"]]]
				},
				{
					"name": "Trace",
					"description": "The lowest log level, used when calling {@link ILogger.trace}.",
					"type": [[["10"]]]
				},
				{
					"name": "Warn",
					"description": "The warning level, used when calling {@link ILogger.warn}.",
					"type": [[["40"]]]
				}
			]
		},
		{
			"name": "PluginHook",
			"meta": {
				"line": 7,
				"file": "Enums.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "PostInitialization",
					"type": [[["\"postInitialization\""]]]
				},
				{
					"name": "PostLogin",
					"type": [[["\"postLogin\""]]]
				},
				{
					"name": "PreGenericsInitialization",
					"type": [[["\"preGenericsInitialization\""]]]
				},
				{
					"name": "PreInitialization",
					"type": [[["\"preInitialization\""]]]
				},
				{
					"name": "PreLogin",
					"type": [[["\"preLogin\""]]]
				}
			]
		},
		{
			"name": "PreconditionRunCondition",
			"description": "The condition for a {@link PreconditionContainerArray}.",
			"meta": {
				"line": 38,
				"file": "PreconditionContainerArray.ts",
				"path": "src/lib/utils/preconditions"
			},
			"props": [
				{
					"name": "And",
					"description": "Defines a condition where all the entries must pass. This uses {@link PreconditionConditionAnd}.",
					"type": [[["0"]]]
				},
				{
					"name": "Or",
					"description": "Defines a condition where at least one entry must pass. This uses {@link PreconditionConditionOr}.",
					"type": [[["1"]]]
				}
			]
		},
		{
			"name": "PreconditionRunMode",
			"description": "The run mode for a {@link PreconditionContainerArray}.",
			"see": [],
			"deprecated": false,
			"meta": {
				"line": 19,
				"file": "PreconditionContainerArray.ts",
				"path": "src/lib/utils/preconditions"
			},
			"props": [
				{
					"name": "Parallel",
					"description": "All entries are run in parallel using `Promise.all`, then the results are processed after all of them have\ncompleted.",
					"type": [[["1"]]]
				},
				{
					"name": "Sequential",
					"description": "The entries are run sequentially, this is the default behaviour and can be slow when doing long asynchronous\ntasks, but is performance savvy.",
					"type": [[["0"]]]
				}
			]
		},
		{
			"name": "ArgOptions",
			"meta": {
				"line": 714,
				"file": "Args.ts",
				"path": "src/lib/parsers"
			}
		},
		{
			"name": "ArgType",
			"meta": {
				"line": 687,
				"file": "Args.ts",
				"path": "src/lib/parsers"
			},
			"props": [
				{
					"name": "boolean",
					"optional": false,
					"type": [[["boolean"]]]
				},
				{
					"name": "channel",
					"optional": false,
					"type": [[["ChannelTypes"]]]
				},
				{
					"name": "date",
					"optional": false,
					"type": [[["Date"]]]
				},
				{
					"name": "dmChannel",
					"optional": false,
					"type": [[["DMChannel"]]]
				},
				{
					"name": "float",
					"optional": false,
					"type": [[["number"]]]
				},
				{
					"name": "guildCategoryChannel",
					"optional": false,
					"type": [[["CategoryChannel"]]]
				},
				{
					"name": "guildChannel",
					"optional": false,
					"type": [[["GuildBasedChannelTypes"]]]
				},
				{
					"name": "guildNewsChannel",
					"optional": false,
					"type": [[["NewsChannel"]]]
				},
				{
					"name": "guildNewsThreadChannel",
					"optional": false,
					"type": [
						[
							["ThreadChannel", " & {"],
							["\nparent", ": "],
							["null", " | "],
							["NewsChannel", ","],
							["\ntype", ": "],
							["'GUILD", "_"],
							["NEWS", "_"],
							["THREAD'\n", "}"]
						]
					]
				},
				{
					"name": "guildPrivateThreadChannel",
					"optional": false,
					"type": [
						[
							["ThreadChannel", " & {"],
							["\nparent", ": "],
							["null", " | "],
							["TextChannel", ","],
							["\ntype", ": "],
							["'GUILD", "_"],
							["PRIVATE", "_"],
							["THREAD'\n", "}"]
						]
					]
				},
				{
					"name": "guildPublicThreadChannel",
					"optional": false,
					"type": [
						[
							["ThreadChannel", " & {"],
							["\nparent", ": "],
							["null", " | "],
							["TextChannel", ","],
							["\ntype", ": "],
							["'GUILD", "_"],
							["PUBLIC", "_"],
							["THREAD'\n", "}"]
						]
					]
				},
				{
					"name": "guildStageVoiceChannel",
					"optional": false,
					"type": [[["StageChannel"]]]
				},
				{
					"name": "guildTextChannel",
					"optional": false,
					"type": [[["TextChannel"]]]
				},
				{
					"name": "guildThreadChannel",
					"optional": false,
					"type": [[["ThreadChannel"]]]
				},
				{
					"name": "guildVoiceChannel",
					"optional": false,
					"type": [[["VoiceChannel"]]]
				},
				{
					"name": "hyperlink",
					"optional": false,
					"type": [[["URL"]]]
				},
				{
					"name": "integer",
					"optional": false,
					"type": [[["number"]]]
				},
				{
					"name": "member",
					"optional": false,
					"type": [[["GuildMember"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "number",
					"optional": false,
					"type": [[["number"]]]
				},
				{
					"name": "role",
					"optional": false,
					"type": [[["Role"]]]
				},
				{
					"name": "string",
					"optional": false,
					"type": [[["string"]]]
				},
				{
					"name": "url",
					"optional": false,
					"type": [[["URL"]]]
				},
				{
					"name": "user",
					"optional": false,
					"type": [[["User"]]]
				}
			]
		},
		{
			"name": "ArgsNextCallback",
			"description": "The value to be mapped.",
			"meta": {
				"line": 727,
				"file": "Args.ts",
				"path": "src/lib/parsers"
			},
			"params": [
				{
					"name": "value",
					"optional": false,
					"type": [[["string"]]]
				}
			],
			"returns": [
				[
					["Maybe", "<"],
					["T", ">"]
				]
			]
		},
		{
			"name": "ArgumentContext",
			"meta": {
				"line": 90,
				"file": "Argument.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "args",
					"optional": false,
					"type": [[["Args"]]]
				},
				{
					"name": "argument",
					"optional": false,
					"type": [
						[
							["IArgument", "<"],
							["T", ">"]
						]
					]
				},
				{
					"name": "command",
					"optional": false,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					]
				},
				{
					"name": "commandContext",
					"optional": false,
					"type": [[["CommandContext"]]]
				},
				{
					"name": "inclusive",
					"optional": true,
					"type": [[["boolean"]]]
				},
				{
					"name": "maximum",
					"optional": true,
					"type": [[["number"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "minimum",
					"optional": true,
					"type": [[["number"]]]
				}
			]
		},
		{
			"name": "ArgumentOptions",
			"meta": {
				"line": 88,
				"file": "Argument.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "ClientLoggerOptions",
			"meta": {
				"line": 299,
				"file": "SapphireClient.ts",
				"path": "src/lib"
			},
			"props": [
				{
					"name": "instance",
					"optional": true,
					"type": [[["ILogger"]]]
				},
				{
					"name": "level",
					"optional": true,
					"type": [[["LogLevel"]]]
				}
			]
		},
		{
			"name": "CommandAcceptedPayload",
			"meta": {
				"line": 113,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "command",
					"optional": false,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					]
				},
				{
					"name": "context",
					"optional": false,
					"type": [[["CommandContext"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "parameters",
					"optional": false,
					"type": [[["string"]]]
				}
			]
		},
		{
			"name": "CommandContext",
			"meta": {
				"line": 513,
				"file": "Command.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "commandName",
					"description": "The alias used to run this command.",
					"optional": false,
					"type": [[["string"]]]
				},
				{
					"name": "commandPrefix",
					"description": "The matched prefix, this will always be the same as {@link Command.RunContext.prefix} if it was a string, otherwise it is\nthe result of doing `prefix.exec(content)[0]`.",
					"optional": false,
					"type": [[["string"]]]
				},
				{
					"name": "prefix",
					"description": "The prefix used to run this command.",
					"optional": false,
					"type": [[["string", " | "], ["RegExp"]]]
				}
			]
		},
		{
			"name": "CommandDeniedPayload",
			"meta": {
				"line": 108,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "command",
					"optional": false,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					]
				},
				{
					"name": "context",
					"optional": false,
					"type": [[["CommandContext"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "parameters",
					"optional": false,
					"type": [[["string"]]]
				}
			]
		},
		{
			"name": "CommandErrorPayload",
			"meta": {
				"line": 124,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "args",
					"optional": false,
					"type": [[["T"]]]
				},
				{
					"name": "command",
					"optional": false,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					]
				},
				{
					"name": "context",
					"optional": false,
					"type": [[["CommandContext"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "parameters",
					"optional": false,
					"type": [[["string"]]]
				},
				{
					"name": "piece",
					"optional": false,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					]
				}
			]
		},
		{
			"name": "CommandFinishPayload",
			"meta": {
				"line": 122,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "args",
					"optional": false,
					"type": [[["T"]]]
				},
				{
					"name": "command",
					"optional": false,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					]
				},
				{
					"name": "context",
					"optional": false,
					"type": [[["CommandContext"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "parameters",
					"optional": false,
					"type": [[["string"]]]
				}
			]
		},
		{
			"name": "CommandJSON",
			"meta": {
				"line": 531,
				"file": "Command.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "category",
					"optional": false,
					"type": [[["null", " | "], ["string"]]]
				},
				{
					"name": "description",
					"optional": false,
					"type": [[["string"]]]
				},
				{
					"name": "detailedDescription",
					"optional": false,
					"type": [[["string"]]]
				}
			]
		},
		{
			"name": "CommandOptions",
			"description": "The {@link Command} options.",
			"see": [],
			"deprecated": false,
			"meta": {
				"line": 391,
				"file": "Command.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "cooldownDelay",
					"description": "The time in milliseconds for the cooldown entries to reset, if set to a non-zero value alongside {@link Command.Options.cooldownLimit}, the `Cooldown` precondition will be added to the list.",
					"optional": true,
					"default": "0",
					"type": [[["number"]]]
				},
				{
					"name": "cooldownFilteredUsers",
					"description": "The users that are exempt from the Cooldown precondition.\nUse this to filter out someone like a bot owner",
					"optional": true,
					"default": "undefined",
					"type": [
						[
							["Array", "<"],
							["string", ">"]
						]
					]
				},
				{
					"name": "cooldownLimit",
					"description": "The amount of entries the cooldown can have before filling up, if set to a non-zero value alongside {@link Command.Options.cooldownDelay}, the `Cooldown` precondition will be added to the list.",
					"optional": true,
					"default": "1",
					"type": [[["number"]]]
				},
				{
					"name": "cooldownScope",
					"description": "The scope of the cooldown entries.",
					"optional": true,
					"default": "BucketScope.User",
					"type": [[["BucketScope"]]]
				},
				{
					"name": "description",
					"description": "The description for the command.",
					"optional": true,
					"default": "''",
					"type": [[["string"]]]
				},
				{
					"name": "detailedDescription",
					"description": "The detailed description for the command.",
					"optional": true,
					"default": "''",
					"type": [[["string"]]]
				},
				{
					"name": "flags",
					"description": "The accepted flags. Flags are key-only identifiers that can be placed anywhere in the command. Two different types are accepted:\n* An array of strings, e.g. [`silent`].\n* A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).",
					"optional": true,
					"default": "[]",
					"type": [
						[
							["boolean", " | "],
							["readonly", " "],
							["Array", "<"],
							["string", ">"]
						]
					]
				},
				{
					"name": "fullCategory",
					"description": "The full category path for the command",
					"optional": true,
					"default": "'An array of folder names that lead back to the folder that is registered for in the commands store'",
					"type": [
						[
							["Array", "<"],
							["string", ">"]
						]
					]
				},
				{
					"name": "generateDashLessAliases",
					"description": "Whether to add aliases for commands with dashes in them",
					"optional": true,
					"default": "false",
					"type": [[["boolean"]]]
				},
				{
					"name": "nsfw",
					"description": "Sets whether or not the command should be treated as NSFW. If set to true, the `NSFW` precondition will be added to the list.",
					"optional": true,
					"default": "false",
					"type": [[["boolean"]]]
				},
				{
					"name": "options",
					"description": "The accepted options. Options are key-value identifiers that can be placed anywhere in the command. Two different types are accepted:\n* An array of strings, e.g. [`silent`].\n* A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).",
					"optional": true,
					"default": "[]",
					"type": [
						[
							["boolean", " | "],
							["readonly", " "],
							["Array", "<"],
							["string", ">"]
						]
					]
				},
				{
					"name": "preconditions",
					"description": "The {@link Precondition}s to be run, accepts an array of their names.",
					"optional": true,
					"default": "[]",
					"type": [
						[
							["readonly", " "],
							["Array", "<"],
							["PreconditionEntryResolvable", ">"]
						]
					]
				},
				{
					"name": "prefixes",
					"description": "The prefixes for both flags and options.",
					"optional": true,
					"default": "['--', '-', '‚Äî']",
					"type": [
						[
							["Array", "<"],
							["string", ">"]
						]
					]
				},
				{
					"name": "quotes",
					"description": "The quotes accepted by this command, pass `[]` to disable them.",
					"optional": true,
					"default": "[\n  ['\"', '\"'], // Double quotes\n  ['‚Äú', '‚Äù'], // Fancy quotes (on iOS)\n  ['„Äå', '„Äç'] // Corner brackets (CJK)\n]",
					"type": [
						[
							["Array", "<["],
							["string", ", "],
							["string", "]>"]
						]
					]
				},
				{
					"name": "requiredClientPermissions",
					"description": "The required permissions for the client.",
					"optional": true,
					"default": "0",
					"type": [[["PermissionResolvable"]]]
				},
				{
					"name": "requiredUserPermissions",
					"description": "The required permissions for the user.",
					"optional": true,
					"default": "0",
					"type": [[["PermissionResolvable"]]]
				},
				{
					"name": "runIn",
					"description": "The channels the command should run in. If set to `null`, no precondition entry will be added. Some optimizations are applied when given an array to reduce the amount of preconditions run (e.g. `'GUILD_TEXT'` and `'GUILD_NEWS'` becomes `'GUILD_ANY'`, and if both `'DM'` and `'GUILD_ANY'` are defined, then no precondition entry is added as it runs in all channels).",
					"optional": true,
					"default": "null",
					"type": [
						[
							["null", " | "],
							["CommandOptionsRunType", " | "],
							["CommandOptionsRunTypeEnum", " | "],
							["readonly", " "],
							["Array", "<"],
							["CommandOptionsRunType", " | "],
							["CommandOptionsRunTypeEnum", ">"]
						]
					]
				},
				{
					"name": "separators",
					"description": "The flag separators.",
					"optional": true,
					"default": "['=', ':']",
					"type": [
						[
							["Array", "<"],
							["string", ">"]
						]
					]
				},
				{
					"name": "typing",
					"description": "If {@link SapphireClient.typing} is true, this option will override it.\nOtherwise, this option has no effect - you may call {@link Channel#sendTyping}` in the run method if you want specific commands to display the typing status.",
					"optional": true,
					"default": "true",
					"type": [[["boolean"]]]
				}
			]
		},
		{
			"name": "CommandRunPayload",
			"meta": {
				"line": 118,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "args",
					"optional": false,
					"type": [[["T"]]]
				},
				{
					"name": "command",
					"optional": false,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					]
				},
				{
					"name": "context",
					"optional": false,
					"type": [[["CommandContext"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "parameters",
					"optional": false,
					"type": [[["string"]]]
				}
			]
		},
		{
			"name": "CommandSuccessPayload",
			"meta": {
				"line": 128,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "args",
					"optional": false,
					"type": [[["T"]]]
				},
				{
					"name": "command",
					"optional": false,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					]
				},
				{
					"name": "context",
					"optional": false,
					"type": [[["CommandContext"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "parameters",
					"optional": false,
					"type": [[["string"]]]
				},
				{
					"name": "result",
					"optional": false,
					"type": [[["unknown"]]]
				}
			]
		},
		{
			"name": "CommandTypingErrorPayload",
			"meta": {
				"line": 132,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "args",
					"optional": false,
					"type": [[["T"]]]
				},
				{
					"name": "command",
					"optional": false,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					]
				},
				{
					"name": "context",
					"optional": false,
					"type": [[["CommandContext"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "parameters",
					"optional": false,
					"type": [[["string"]]]
				}
			]
		},
		{
			"name": "CooldownContext",
			"meta": {
				"line": 8,
				"file": "Cooldown.ts",
				"path": "src/preconditions"
			},
			"props": [
				{
					"name": "delay",
					"optional": false,
					"type": [[["number"]]]
				},
				{
					"name": "external",
					"optional": true,
					"type": [[["boolean"]]]
				},
				{
					"name": "filteredUsers",
					"optional": true,
					"type": [
						[
							["Array", "<"],
							["string", ">"]
						]
					]
				},
				{
					"name": "limit",
					"optional": true,
					"type": [[["number"]]]
				},
				{
					"name": "scope",
					"optional": true,
					"type": [[["BucketScope"]]]
				}
			]
		},
		{
			"name": "CooldownOptions",
			"meta": {
				"line": 304,
				"file": "SapphireClient.ts",
				"path": "src/lib"
			},
			"props": [
				{
					"name": "delay",
					"optional": true,
					"type": [[["number"]]]
				},
				{
					"name": "filteredCommands",
					"optional": true,
					"type": [
						[
							["Array", "<"],
							["string", ">"]
						]
					]
				},
				{
					"name": "filteredUsers",
					"optional": true,
					"type": [
						[
							["Array", "<"],
							["string", ">"]
						]
					]
				},
				{
					"name": "limit",
					"optional": true,
					"type": [[["number"]]]
				},
				{
					"name": "scope",
					"optional": true,
					"type": [[["BucketScope"]]]
				}
			]
		},
		{
			"name": "ExtendedArgumentContext",
			"see": [],
			"deprecated": true,
			"meta": {
				"line": 86,
				"file": "ExtendedArgument.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "args",
					"optional": false,
					"type": [[["Args"]]]
				},
				{
					"name": "argument",
					"optional": false,
					"type": [
						[
							["IArgument", "<"],
							["unknown", ">"]
						]
					]
				},
				{
					"name": "command",
					"optional": false,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					]
				},
				{
					"name": "commandContext",
					"optional": false,
					"type": [[["CommandContext"]]]
				},
				{
					"name": "inclusive",
					"optional": true,
					"type": [[["boolean"]]]
				},
				{
					"name": "maximum",
					"optional": true,
					"type": [[["number"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "minimum",
					"optional": true,
					"type": [[["number"]]]
				},
				{
					"name": "parameter",
					"description": "The canonical parameter specified by the user in the command, as\na string, equivalent to the first parameter of {@link Argument#run}.\nThis allows {@link ExtendedArgument#handle} to access the original\nargument, which is useful for returning {@link Argument#error} so\nthat you don't have to convert the parsed argument back into a\nstring.",
					"optional": false,
					"type": [[["string"]]]
				}
			]
		},
		{
			"name": "ExtendedArgumentOptions",
			"see": [],
			"deprecated": true,
			"meta": {
				"line": 75,
				"file": "ExtendedArgument.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "baseArgument",
					"description": "The name of the underlying argument whose value is used to compute\nthe extended argument value; see {@link ArgType} for valid keys.",
					"optional": false,
					"type": [[["K"]]]
				}
			]
		},
		{
			"name": "IArgument",
			"meta": {
				"line": 20,
				"file": "Argument.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "name",
					"description": "The name of the argument, this is used to make the identification of an argument easier.",
					"optional": false,
					"type": [[["string"]]]
				},
				{
					"name": "run",
					"description": "The method which is called when invoking the argument.",
					"optional": false,
					"type": [
						[
							["("],
							["parameter", ": "],
							["string", ", "],
							["context", ": "],
							["Context", "<"],
							["T", ">) => "],
							["Result", "<"],
							["T", ">"]
						]
					]
				}
			]
		},
		{
			"name": "ICommandPayload",
			"meta": {
				"line": 101,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "command",
					"optional": false,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				}
			]
		},
		{
			"name": "ILogger",
			"meta": {
				"line": 41,
				"file": "ILogger.ts",
				"path": "src/lib/utils/logger"
			},
			"props": [
				{
					"name": "debug",
					"description": "Alias of {@link ILogger.write} with {@link LogLevel.Debug} as level.",
					"optional": false,
					"type": [[["("], ["values", ": "], ["readonly", " "], ["Array", "<"], ["unknown", ">) => "], ["void"]]]
				},
				{
					"name": "error",
					"description": "Alias of {@link ILogger.write} with {@link LogLevel.Error} as level.",
					"optional": false,
					"type": [[["("], ["values", ": "], ["readonly", " "], ["Array", "<"], ["unknown", ">) => "], ["void"]]]
				},
				{
					"name": "fatal",
					"description": "Alias of {@link ILogger.write} with {@link LogLevel.Fatal} as level.",
					"optional": false,
					"type": [[["("], ["values", ": "], ["readonly", " "], ["Array", "<"], ["unknown", ">) => "], ["void"]]]
				},
				{
					"name": "has",
					"description": "Checks whether a level is supported.",
					"optional": false,
					"type": [[["("], ["level", ": "], ["LogLevel", ") => "], ["boolean"]]]
				},
				{
					"name": "info",
					"description": "Alias of {@link ILogger.write} with {@link LogLevel.Info} as level.",
					"optional": false,
					"type": [[["("], ["values", ": "], ["readonly", " "], ["Array", "<"], ["unknown", ">) => "], ["void"]]]
				},
				{
					"name": "trace",
					"description": "Alias of {@link ILogger.write} with {@link LogLevel.Trace} as level.",
					"optional": false,
					"type": [[["("], ["values", ": "], ["readonly", " "], ["Array", "<"], ["unknown", ">) => "], ["void"]]]
				},
				{
					"name": "warn",
					"description": "Alias of {@link ILogger.write} with {@link LogLevel.Warn} as level.",
					"optional": false,
					"type": [[["("], ["values", ": "], ["readonly", " "], ["Array", "<"], ["unknown", ">) => "], ["void"]]]
				},
				{
					"name": "write",
					"description": "Writes the log message given a level and the value(s).",
					"optional": false,
					"type": [
						[
							["("],
							["level", ": "],
							["LogLevel", ", "],
							["values", ": "],
							["readonly", " "],
							["Array", "<"],
							["unknown", ">) => "],
							["void"]
						]
					]
				}
			]
		},
		{
			"name": "IPieceError",
			"meta": {
				"line": 83,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "piece",
					"optional": false,
					"type": [
						[
							["Piece", "<"],
							["PieceOptions", ">"]
						]
					]
				}
			]
		},
		{
			"name": "IPreconditionCondition",
			"description": "Defines the condition for {@link PreconditionContainerArray}s to run.",
			"see": [],
			"deprecated": false,
			"meta": {
				"line": 10,
				"file": "IPreconditionCondition.ts",
				"path": "src/lib/utils/preconditions/conditions"
			},
			"props": [
				{
					"name": "parallel",
					"description": "Runs all the containers using `Promise.all`, then checks the results once all tasks finished running.",
					"optional": false,
					"type": [
						[
							["("],
							["message", ": "],
							["Message", "<"],
							["boolean", ">, "],
							["command", ": "],
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">, "],
							["entries", ": "],
							["readonly", " "],
							["Array", "<"],
							["IPreconditionContainer", ">, "],
							["context", ": "],
							["PreconditionContext", ") => "],
							["PreconditionContainerReturn"]
						]
					]
				},
				{
					"name": "sequential",
					"description": "Runs the containers one by one.",
					"optional": false,
					"type": [
						[
							["("],
							["message", ": "],
							["Message", "<"],
							["boolean", ">, "],
							["command", ": "],
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">, "],
							["entries", ": "],
							["readonly", " "],
							["Array", "<"],
							["IPreconditionContainer", ">, "],
							["context", ": "],
							["PreconditionContext", ") => "],
							["PreconditionContainerReturn"]
						]
					]
				}
			]
		},
		{
			"name": "IPreconditionContainer",
			"description": "An abstracted precondition container to be implemented by classes.",
			"see": [],
			"deprecated": false,
			"meta": {
				"line": 30,
				"file": "IPreconditionContainer.ts",
				"path": "src/lib/utils/preconditions"
			},
			"props": [
				{
					"name": "run",
					"description": "Runs a precondition container.",
					"optional": false,
					"type": [
						[
							["("],
							["message", ": "],
							["Message", "<"],
							["boolean", ">, "],
							["command", ": "],
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">, "],
							["context", ": "],
							["PreconditionContext", ") => "],
							["PreconditionContainerReturn"]
						]
					]
				}
			]
		},
		{
			"name": "ListenerErrorPayload",
			"meta": {
				"line": 87,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "piece",
					"optional": false,
					"type": [
						[
							["Listener", "<"],
							["''", ", "],
							["ListenerOptions", ">"]
						]
					]
				}
			]
		},
		{
			"name": "ListenerJSON",
			"meta": {
				"line": 122,
				"file": "Listener.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "event",
					"optional": false,
					"type": [[["string"]]]
				},
				{
					"name": "once",
					"optional": false,
					"type": [[["boolean"]]]
				}
			]
		},
		{
			"name": "ListenerOptions",
			"meta": {
				"line": 116,
				"file": "Listener.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "emitter",
					"optional": true,
					"type": [
						[
							["EventEmitter", " | "],
							["keyof", " "],
							["Client", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "event",
					"optional": true,
					"type": [[["string"]]]
				},
				{
					"name": "once",
					"optional": true,
					"type": [[["boolean"]]]
				}
			]
		},
		{
			"name": "PreCommandRunPayload",
			"meta": {
				"line": 106,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "command",
					"optional": false,
					"type": [
						[
							["Command", "<"],
							["Args", ", "],
							["CommandOptions", ">"]
						]
					]
				},
				{
					"name": "context",
					"optional": false,
					"type": [[["CommandContext"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "parameters",
					"optional": false,
					"type": [[["string"]]]
				}
			]
		},
		{
			"name": "PreconditionArrayResolvableDetails",
			"description": "Defines the detailed options for the {@link PreconditionContainerArray}, where both the {@link PreconditionRunMode} and the\nentries can be defined.",
			"see": [],
			"deprecated": false,
			"meta": {
				"line": 57,
				"file": "PreconditionContainerArray.ts",
				"path": "src/lib/utils/preconditions"
			},
			"props": [
				{
					"name": "entries",
					"description": "The data that will be used to resolve {@link IPreconditionContainer} dependent of this one.",
					"optional": false,
					"type": [
						[
							["readonly", " "],
							["Array", "<"],
							["PreconditionEntryResolvable", ">"]
						]
					]
				},
				{
					"name": "mode",
					"description": "The mode the {@link PreconditionContainerArray} will run.",
					"optional": false,
					"type": [[["PreconditionRunMode"]]]
				}
			]
		},
		{
			"name": "PreconditionContext",
			"meta": {
				"line": 117,
				"file": "Precondition.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "external",
					"optional": true,
					"type": [[["boolean"]]]
				}
			]
		},
		{
			"name": "PreconditionOptions",
			"meta": {
				"line": 108,
				"file": "Precondition.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "position",
					"description": "The position for the precondition to be set at in the global precondition list. If set to `null`, this\nprecondition will not be set as a global one.",
					"optional": true,
					"default": "null",
					"type": [[["null", " | "], ["number"]]]
				}
			]
		},
		{
			"name": "PreconditionSingleResolvableDetails",
			"description": "Defines the detailed options for the {@link PreconditionContainerSingle}, where both the {@link PreconditionContext} and the\nname of the precondition can be defined.",
			"see": [],
			"deprecated": false,
			"meta": {
				"line": 25,
				"file": "PreconditionContainerSingle.ts",
				"path": "src/lib/utils/preconditions"
			},
			"props": [
				{
					"name": "context",
					"description": "The context to be set at {@link PreconditionContainerSingle.context}.",
					"optional": false,
					"type": [
						[
							["Preconditions", "["],
							["K", "]"]
						]
					]
				},
				{
					"name": "name",
					"description": "The name of the precondition to retrieve from {@link SapphireClient.preconditions}.",
					"optional": false,
					"type": [[["K"]]]
				}
			]
		},
		{
			"name": "Preconditions",
			"description": "The registered preconditions and their contexts, if any. When registering new ones, it is recommended to use\n[module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation) so\ncustom ones are registered.",
			"extendedDescription": "When a key's value is `never`, it means that it does not take any context, which allows you to pass its identifier as\na bare string (e.g. `preconditions: ['NSFW']`), however, if context is required, a non-`never` type should be passed,\nwhich will type {@link PreconditionContainerArray#append} and require an object with the name and a `context` with\nthe defined type.",
			"see": [],
			"deprecated": false,
			"meta": {
				"line": 83,
				"file": "Precondition.ts",
				"path": "src/lib/structures"
			},
			"props": [
				{
					"name": "ClientPermissions",
					"optional": false,
					"type": [[["{"], ["\npermissions", ": "], ["Permissions\n", "}"]]]
				},
				{
					"name": "Cooldown",
					"optional": false,
					"type": [[["CooldownContext"]]]
				},
				{
					"name": "DMOnly",
					"optional": false,
					"type": [[["never"]]]
				},
				{
					"name": "Enabled",
					"optional": false,
					"type": [[["never"]]]
				},
				{
					"name": "GuildNewsOnly",
					"optional": false,
					"type": [[["never"]]]
				},
				{
					"name": "GuildNewsThreadOnly",
					"optional": false,
					"type": [[["never"]]]
				},
				{
					"name": "GuildOnly",
					"optional": false,
					"type": [[["never"]]]
				},
				{
					"name": "GuildPrivateThreadOnly",
					"optional": false,
					"type": [[["never"]]]
				},
				{
					"name": "GuildPublicThreadOnly",
					"optional": false,
					"type": [[["never"]]]
				},
				{
					"name": "GuildTextOnly",
					"optional": false,
					"type": [[["never"]]]
				},
				{
					"name": "GuildThreadOnly",
					"optional": false,
					"type": [[["never"]]]
				},
				{
					"name": "NSFW",
					"optional": false,
					"type": [[["never"]]]
				},
				{
					"name": "UserPermissions",
					"optional": false,
					"type": [[["{"], ["\npermissions", ": "], ["Permissions\n", "}"]]]
				}
			]
		},
		{
			"name": "RepeatArgOptions",
			"meta": {
				"line": 716,
				"file": "Args.ts",
				"path": "src/lib/parsers"
			},
			"props": [
				{
					"name": "times",
					"description": "The maximum amount of times the argument can be repeated.",
					"optional": true,
					"default": "Infinity",
					"type": [[["number"]]]
				}
			]
		},
		{
			"name": "SapphireClientOptions",
			"meta": {
				"line": 28,
				"file": "SapphireClient.ts",
				"path": "src/lib"
			},
			"props": [
				{
					"name": "baseUserDirectory",
					"description": "The base user directory, if set to `null`, Sapphire will not call {@link StoreRegistry.registerPath},\nmeaning that you will need to manually set each folder for each store. Please read the aforementioned method's\ndocumentation for more information.",
					"optional": true,
					"default": "undefined",
					"type": [[["null", " | "], ["string"]]]
				},
				{
					"name": "caseInsensitiveCommands",
					"description": "Whether commands can be case insensitive",
					"optional": true,
					"default": "false",
					"type": [[["null", " | "], ["boolean"]]]
				},
				{
					"name": "caseInsensitivePrefixes",
					"description": "Whether prefixes can be case insensitive",
					"optional": true,
					"default": "false",
					"type": [[["null", " | "], ["boolean"]]]
				},
				{
					"name": "defaultCooldown",
					"description": "Sets the default cooldown time for all commands.",
					"optional": true,
					"default": "\"No cooldown options\"",
					"type": [[["CooldownOptions"]]]
				},
				{
					"name": "defaultPrefix",
					"description": "The default prefix, in case of `null`, only mention prefix will trigger the bot's commands.",
					"optional": true,
					"default": "null",
					"type": [[["SapphirePrefix"]]]
				},
				{
					"name": "enableLoaderTraceLoggings",
					"description": "Whether or not trace logging should be enabled.",
					"optional": true,
					"default": "container.logger.has(LogLevel.Trace)",
					"type": [[["boolean"]]]
				},
				{
					"name": "fetchPrefix",
					"description": "The prefix hook, by default it is a callback function that returns {@link SapphireClientOptions.defaultPrefix}.",
					"optional": true,
					"default": "() => client.options.defaultPrefix",
					"type": [[["SapphirePrefixHook"]]]
				},
				{
					"name": "id",
					"description": "The client's ID, this is automatically set by the CoreReady event.",
					"optional": true,
					"default": "this.client.user?.id ?? null",
					"type": [[["string"]]]
				},
				{
					"name": "loadDefaultErrorListeners",
					"description": "If Sapphire should load our pre-included error event listeners that log any encountered errors to the {@link SapphireClient.logger} instance",
					"optional": true,
					"default": "true",
					"type": [[["boolean"]]]
				},
				{
					"name": "logger",
					"description": "The logger options, defaults to an instance of {@link Logger} when {@link ClientLoggerOptions.instance} is not specified.",
					"optional": true,
					"default": "{ instance: new Logger(LogLevel.Info) }",
					"type": [[["ClientLoggerOptions"]]]
				},
				{
					"name": "regexPrefix",
					"description": "The regex prefix, an alternative to a mention or regular prefix to allow creating natural language command messages",
					"optional": true,
					"type": [[["RegExp"]]]
				},
				{
					"name": "typing",
					"description": "Controls whether the bot will automatically appear to be typing when a command is accepted.",
					"optional": true,
					"default": "false",
					"type": [[["boolean"]]]
				}
			]
		},
		{
			"name": "SapphirePluginAsyncHook",
			"meta": {
				"line": 9,
				"file": "PluginManager.ts",
				"path": "src/lib/plugins"
			},
			"params": [
				{
					"name": "options",
					"optional": false,
					"type": [[["ClientOptions"]]]
				}
			],
			"returns": [[["unknown"]]]
		},
		{
			"name": "SapphirePluginHook",
			"meta": {
				"line": 14,
				"file": "PluginManager.ts",
				"path": "src/lib/plugins"
			},
			"params": [
				{
					"name": "options",
					"optional": false,
					"type": [[["ClientOptions"]]]
				}
			],
			"returns": [[["unknown"]]]
		},
		{
			"name": "SapphirePluginHookEntry",
			"meta": {
				"line": 18,
				"file": "PluginManager.ts",
				"path": "src/lib/plugins"
			},
			"props": [
				{
					"name": "hook",
					"optional": false,
					"type": [[["T"]]]
				},
				{
					"name": "name",
					"optional": true,
					"type": [[["string"]]]
				},
				{
					"name": "type",
					"optional": false,
					"type": [[["PluginHook"]]]
				}
			]
		},
		{
			"name": "SapphirePrefixHook",
			"meta": {
				"line": 24,
				"file": "SapphireClient.ts",
				"path": "src/lib"
			},
			"params": [
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				}
			],
			"returns": [
				[
					["Awaitable", "<"],
					["SapphirePrefix", ">"]
				]
			]
		},
		{
			"name": "SimplePreconditionSingleResolvableDetails",
			"description": "Defines the simple options for the {@link PreconditionContainerSingle}, where only the name of the precondition can\nbe defined.",
			"see": [],
			"deprecated": false,
			"meta": {
				"line": 12,
				"file": "PreconditionContainerSingle.ts",
				"path": "src/lib/utils/preconditions"
			},
			"props": [
				{
					"name": "name",
					"description": "The name of the precondition to retrieve from {@link SapphireClient.preconditions}.",
					"optional": false,
					"type": [[["SimplePreconditionKeys"]]]
				}
			]
		},
		{
			"name": "UnknownCommandNamePayload",
			"meta": {
				"line": 91,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "commandPrefix",
					"optional": false,
					"type": [[["string"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "prefix",
					"optional": false,
					"type": [[["string", " | "], ["RegExp"]]]
				}
			]
		},
		{
			"name": "UnknownCommandPayload",
			"meta": {
				"line": 97,
				"file": "Events.ts",
				"path": "src/lib/types"
			},
			"props": [
				{
					"name": "commandName",
					"optional": false,
					"type": [[["string"]]]
				},
				{
					"name": "commandPrefix",
					"optional": false,
					"type": [[["string"]]]
				},
				{
					"name": "message",
					"optional": false,
					"type": [
						[
							["Message", "<"],
							["boolean", ">"]
						]
					]
				},
				{
					"name": "prefix",
					"optional": false,
					"type": [[["string", " | "], ["RegExp"]]]
				}
			]
		},
		{
			"name": "ArgumentResult",
			"description": "Defines a synchronous result of an {@link Argument}, check {@link Argument.AsyncResult} for the asynchronous version.",
			"type": [
				[
					["Awaitable", "<"],
					["Result", "<"],
					["T", ", "],
					["UserError", ">>"]
				]
			],
			"meta": {
				"line": 13,
				"file": "Argument.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "AsyncArgumentResult",
			"description": "Defines an asynchronous result of an {@link Argument}, check {@link Argument.Result} for the synchronous version.",
			"type": [
				[
					["Promise", "<"],
					["Result", "<"],
					["T", ", "],
					["UserError", ">>"]
				]
			],
			"meta": {
				"line": 18,
				"file": "Argument.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "AsyncPluginHooks",
			"type": [[["PluginHook", "."], ["PreLogin", " | "], ["PluginHook", "."], ["PostLogin"]]],
			"meta": {
				"line": 8,
				"file": "PluginManager.ts",
				"path": "src/lib/plugins"
			}
		},
		{
			"name": "AsyncPreconditionContainerReturn",
			"description": "Async-only version of {@link PreconditionContainerReturn}, to be used when the run method is async.",
			"see": [],
			"deprecated": false,
			"type": [
				[
					["Promise", "<"],
					["PreconditionContainerResult", ">"]
				]
			],
			"meta": {
				"line": 24,
				"file": "IPreconditionContainer.ts",
				"path": "src/lib/utils/preconditions"
			}
		},
		{
			"name": "AsyncPreconditionResult",
			"type": [
				[
					["Promise", "<"],
					["Result", "<"],
					["unknown", ", "],
					["UserError", ">>"]
				]
			],
			"meta": {
				"line": 11,
				"file": "Precondition.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "CommandOptionsRunType",
			"description": "The allowed values for {@link Command.Options.runIn}.",
			"see": [],
			"deprecated": false,
			"type": [
				[
					["'DM'", " | "],
					["'GUILD", "_"],
					["TEXT'", " | "],
					["'GUILD", "_"],
					["NEWS'", " | "],
					["'GUILD", "_"],
					["NEWS", "_"],
					["THREAD'", " | "],
					["'GUILD", "_"],
					["PUBLIC", "_"],
					["THREAD'", " | "],
					["'GUILD", "_"],
					["PRIVATE", "_"],
					["THREAD'", " | "],
					["'GUILD", "_"],
					["ANY'"]
				]
			],
			"meta": {
				"line": 345,
				"file": "Command.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "Err",
			"description": "The computation failed.",
			"type": [
				[
					["Lexure", "."],
					["Err", "<"],
					["E", ">"]
				]
			],
			"meta": {
				"line": 21,
				"file": "Result.ts",
				"path": "src/lib/parsers"
			}
		},
		{
			"name": "LogMethods",
			"type": [[["'trace'", " | "], ["'debug'", " | "], ["'info'", " | "], ["'warn'", " | "], ["'error'"]]],
			"meta": {
				"line": 54,
				"file": "Logger.ts",
				"path": "src/lib/utils/logger"
			}
		},
		{
			"name": "Maybe",
			"description": "A type used to express a value that may or may not exist.",
			"type": [[["Some", "<"], ["T", "> | "], ["None"]]],
			"meta": {
				"line": 7,
				"file": "Maybe.ts",
				"path": "src/lib/parsers"
			}
		},
		{
			"name": "None",
			"description": "An empty value.",
			"type": [[["option", "."], ["None"]]],
			"meta": {
				"line": 18,
				"file": "Maybe.ts",
				"path": "src/lib/parsers"
			}
		},
		{
			"name": "Ok",
			"description": "The computation is successful.",
			"type": [
				[
					["Lexure", "."],
					["Ok", "<"],
					["T", ">"]
				]
			],
			"meta": {
				"line": 15,
				"file": "Result.ts",
				"path": "src/lib/parsers"
			}
		},
		{
			"name": "PreconditionArrayResolvable",
			"description": "Defines the data accepted by {@link PreconditionContainerArray}'s constructor.",
			"see": [],
			"deprecated": false,
			"type": [[["readonly", " "], ["Array", "<"], ["PreconditionEntryResolvable", "> | "], ["PreconditionArrayResolvableDetails"]]],
			"meta": {
				"line": 75,
				"file": "PreconditionContainerArray.ts",
				"path": "src/lib/utils/preconditions"
			}
		},
		{
			"name": "PreconditionContainerResult",
			"description": "Defines the result's value for a PreconditionContainer.",
			"see": [],
			"deprecated": false,
			"type": [
				[
					["Result", "<"],
					["unknown", ", "],
					["UserError", ">"]
				]
			],
			"meta": {
				"line": 12,
				"file": "IPreconditionContainer.ts",
				"path": "src/lib/utils/preconditions"
			}
		},
		{
			"name": "PreconditionContainerReturn",
			"description": "Defines the return type of the generic {@link IPreconditionContainer.run}.",
			"see": [],
			"deprecated": false,
			"type": [
				[
					["Awaitable", "<"],
					["PreconditionContainerResult", ">"]
				]
			],
			"meta": {
				"line": 18,
				"file": "IPreconditionContainer.ts",
				"path": "src/lib/utils/preconditions"
			}
		},
		{
			"name": "PreconditionEntryResolvable",
			"description": "Defines the data accepted for each entry of the array.",
			"see": [],
			"deprecated": false,
			"type": [[["PreconditionSingleResolvable", " | "], ["PreconditionArrayResolvable"]]],
			"meta": {
				"line": 83,
				"file": "PreconditionContainerArray.ts",
				"path": "src/lib/utils/preconditions"
			}
		},
		{
			"name": "PreconditionKeys",
			"type": [[["keyof", " "], ["Preconditions"]]],
			"meta": {
				"line": 103,
				"file": "Precondition.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "PreconditionResult",
			"type": [
				[
					["Awaitable", "<"],
					["Result", "<"],
					["unknown", ", "],
					["UserError", ">>"]
				]
			],
			"meta": {
				"line": 10,
				"file": "Precondition.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "PreconditionSingleResolvable",
			"description": "Defines the data accepted by {@link PreconditionContainerSingle}'s constructor.",
			"see": [],
			"deprecated": false,
			"type": [
				[["SimplePreconditionKeys", " | "], ["SimplePreconditionSingleResolvableDetails", " | "], ["PreconditionSingleResolvableDetails"]]
			],
			"meta": {
				"line": 43,
				"file": "PreconditionContainerSingle.ts",
				"path": "src/lib/utils/preconditions"
			}
		},
		{
			"name": "Result",
			"description": "A type used to express computations that can fail.",
			"type": [
				[
					["Ok", "<"],
					["T", "> | "],
					["Err", "<"],
					["E", ">"]
				]
			],
			"meta": {
				"line": 9,
				"file": "Result.ts",
				"path": "src/lib/parsers"
			}
		},
		{
			"name": "SapphirePrefix",
			"description": "A valid prefix in Sapphire.\n* `string`: a single prefix, e.g. `'!'`.\n* `string[]`: an array of prefixes, e.g. `['!', '.']`.\n* `null`: disabled prefix, locks the bot's command usage to mentions only.",
			"type": [[["string", " | "], ["readonly", " "], ["Array", "<"], ["string", "> | "], ["null"]]],
			"meta": {
				"line": 22,
				"file": "SapphireClient.ts",
				"path": "src/lib"
			}
		},
		{
			"name": "SimplePreconditionKeys",
			"type": [
				[
					["unknown", "["],
					["PreconditionKeys", "]"]
				]
			],
			"meta": {
				"line": 104,
				"file": "Precondition.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "Some",
			"description": "A value that exists.",
			"type": [
				[
					["option", "."],
					["Some", "<"],
					["T", ">"]
				]
			],
			"meta": {
				"line": 13,
				"file": "Maybe.ts",
				"path": "src/lib/parsers"
			}
		},
		{
			"name": "SyncPluginHooks",
			"type": [
				[
					["Exclude", "<"],
					["PluginHook", ", "],
					["AsyncPluginHooks", ">"]
				]
			],
			"meta": {
				"line": 13,
				"file": "PluginManager.ts",
				"path": "src/lib/plugins"
			}
		}
	],
	"namespaces": [
		{
			"name": "Argument",
			"typeAliases": [
				{
					"name": "AsyncResult",
					"type": [
						[
							["AsyncArgumentResult", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 105,
						"file": "Argument.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "Context",
					"type": [
						[
							["ArgumentContext", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 103,
						"file": "Argument.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "Options",
					"type": [[["ArgumentOptions"]]],
					"meta": {
						"line": 102,
						"file": "Argument.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "Result",
					"type": [
						[
							["ArgumentResult", "<"],
							["T", ">"]
						]
					],
					"meta": {
						"line": 104,
						"file": "Argument.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"meta": {
				"line": 101,
				"file": "Argument.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "ArgumentError",
			"interfaces": [
				{
					"name": "Options",
					"description": "The options for {@link ArgumentError}.",
					"see": [],
					"deprecated": false,
					"meta": {
						"line": 30,
						"file": "ArgumentError.ts",
						"path": "src/lib/errors"
					},
					"props": [
						{
							"name": "argument",
							"description": "The argument that caused the error.",
							"optional": false,
							"type": [
								[
									["IArgument", "<"],
									["T", ">"]
								]
							]
						},
						{
							"name": "context",
							"description": "The extra context to provide more information about this error.",
							"optional": true,
							"default": "null",
							"type": [[["unknown"]]]
						},
						{
							"name": "identifier",
							"description": "The identifier.",
							"optional": true,
							"default": "argument.name",
							"type": [[["string"]]]
						},
						{
							"name": "message",
							"description": "The message to be passed to the Error constructor.",
							"optional": true,
							"type": [[["string"]]]
						},
						{
							"name": "parameter",
							"description": "The parameter that failed to be parsed.",
							"optional": false,
							"type": [[["string"]]]
						}
					]
				}
			],
			"meta": {
				"line": 25,
				"file": "ArgumentError.ts",
				"path": "src/lib/errors"
			}
		},
		{
			"name": "Command",
			"typeAliases": [
				{
					"name": "Context",
					"type": [[["AliasPiece", "."], ["Context"]]],
					"meta": {
						"line": 540,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "JSON",
					"type": [[["CommandJSON"]]],
					"meta": {
						"line": 539,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "Options",
					"type": [[["CommandOptions"]]],
					"meta": {
						"line": 538,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "RunContext",
					"type": [[["CommandContext"]]],
					"meta": {
						"line": 541,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "RunInTypes",
					"type": [[["CommandOptionsRunType"]]],
					"meta": {
						"line": 542,
						"file": "Command.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"meta": {
				"line": 537,
				"file": "Command.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "CorePreconditions",
			"meta": {
				"line": 1,
				"file": "index.ts",
				"path": "src/preconditions"
			}
		},
		{
			"name": "Listener",
			"typeAliases": [
				{
					"name": "Context",
					"type": [[["Piece", "."], ["Context"]]],
					"meta": {
						"line": 130,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "JSON",
					"type": [[["ListenerJSON"]]],
					"meta": {
						"line": 129,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "Options",
					"type": [[["ListenerOptions"]]],
					"meta": {
						"line": 128,
						"file": "Listener.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"meta": {
				"line": 127,
				"file": "Listener.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "Precondition",
			"typeAliases": [
				{
					"name": "AsyncResult",
					"type": [[["AsyncPreconditionResult"]]],
					"meta": {
						"line": 125,
						"file": "Precondition.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "Context",
					"type": [[["PreconditionContext"]]],
					"meta": {
						"line": 123,
						"file": "Precondition.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "Options",
					"type": [[["PreconditionOptions"]]],
					"meta": {
						"line": 122,
						"file": "Precondition.ts",
						"path": "src/lib/structures"
					}
				},
				{
					"name": "Result",
					"type": [[["PreconditionResult"]]],
					"meta": {
						"line": 124,
						"file": "Precondition.ts",
						"path": "src/lib/structures"
					}
				}
			],
			"meta": {
				"line": 121,
				"file": "Precondition.ts",
				"path": "src/lib/structures"
			}
		},
		{
			"name": "PreconditionError",
			"interfaces": [
				{
					"name": "Options",
					"description": "The options for {@link PreconditionError}.",
					"see": [],
					"deprecated": false,
					"meta": {
						"line": 27,
						"file": "PreconditionError.ts",
						"path": "src/lib/errors"
					},
					"props": [
						{
							"name": "context",
							"description": "The extra context to provide more information about this error.",
							"optional": true,
							"default": "null",
							"type": [[["unknown"]]]
						},
						{
							"name": "identifier",
							"description": "The identifier.",
							"optional": true,
							"default": "precondition.name",
							"type": [[["string"]]]
						},
						{
							"name": "message",
							"description": "The message to be passed to the Error constructor.",
							"optional": true,
							"type": [[["string"]]]
						},
						{
							"name": "precondition",
							"description": "The precondition that caused the error.",
							"optional": false,
							"type": [
								[
									["Precondition", "<"],
									["PreconditionOptions", ">"]
								]
							]
						}
					]
				}
			],
			"meta": {
				"line": 22,
				"file": "PreconditionError.ts",
				"path": "src/lib/errors"
			}
		},
		{
			"name": "Resolvers",
			"interfaces": [
				{
					"name": "MessageResolverOptions",
					"meta": {
						"line": 9,
						"file": "message.ts",
						"path": "src/lib/resolvers"
					},
					"props": [
						{
							"name": "channel",
							"optional": true,
							"type": [
								[["DMChannel", " | "], ["PartialDMChannel", " | "], ["NewsChannel", " | "], ["TextChannel", " | "], ["ThreadChannel"]]
							]
						},
						{
							"name": "message",
							"optional": false,
							"type": [
								[
									["Message", "<"],
									["boolean", ">"]
								]
							]
						}
					]
				}
			],
			"meta": {
				"line": 1,
				"file": "index.ts",
				"path": "src/lib/resolvers"
			}
		},
		{
			"name": "UserError",
			"interfaces": [
				{
					"name": "Options",
					"description": "The options for {@link UserError}.",
					"see": [],
					"deprecated": false,
					"meta": {
						"line": 38,
						"file": "UserError.ts",
						"path": "src/lib/errors"
					},
					"props": [
						{
							"name": "context",
							"description": "The extra context to provide more information about this error.",
							"optional": true,
							"default": "null",
							"type": [[["unknown"]]]
						},
						{
							"name": "identifier",
							"description": "The identifier for this error.",
							"optional": false,
							"type": [[["string"]]]
						},
						{
							"name": "message",
							"description": "The message to be passed to the Error constructor.",
							"optional": true,
							"type": [[["string"]]]
						}
					]
				}
			],
			"meta": {
				"line": 33,
				"file": "UserError.ts",
				"path": "src/lib/errors"
			}
		}
	]
}
